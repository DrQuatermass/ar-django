<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>AR Camera</title>
    {% load static %}
    <!-- OpenCV.js for image feature matching -->
    <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background: #000;
            overflow: hidden;
        }

        #camera-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #camera-stream {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #ar-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .ar-character {
            position: absolute;
            width: 100px;
            height: 100px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            /* Transizioni smooth per posizione, dimensione e opacit√† */
            transition: left 0.2s ease-out, top 0.2s ease-out, transform 0.2s ease-out, opacity 0.3s ease-in-out, width 0.3s ease, height 0.3s ease;
            will-change: transform, opacity;
        }

        .ar-character img {
            width: 80px;
            height: 80px;
            object-fit: cover;
            /* Transizione smooth per dimensione immagine */
            transition: width 0.3s ease, height 0.3s ease;
        }

        .ar-character.active {
            width: 150px;
            height: 150px;
        }

        .ar-character.active img {
            width: 120px;
            height: 120px;
        }

        .ar-character-info {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            text-align: center;
            margin-top: 5px;
            max-width: 120px;
        }


        #controls {
            position: fixed;
            top: 10px;
            left: 10px;
            width: 200px;
            z-index: 20;
            background: rgba(0, 0, 0, 0.2);
            color: white;
            padding: 6px;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            font-size: 10px;
        }

        .info-panel {
            background: rgba(0, 0, 0, 0.3);
            padding: 4px;
            border-radius: 3px;
            margin: 1px 0;
            text-align: left;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .info-title {
            font-size: 9px;
            font-weight: bold;
            margin-right: 4px;
        }

        .info-value {
            font-size: 9px;
            color: #00ff00;
        }

        #character-pointer {
            position: fixed;
            bottom: 80px;
            left: 50%;
            width: 60px;
            height: 60px;
            transform: translate(-50%, 0);
            z-index: 15;
            display: none;
        }

        #pointer-arrow {
            width: 4px;
            height: 50px;
            background: #00ff00;
            margin: 0 auto;
            transform-origin: 50% 100%;
            transition: transform 0.1s ease-out;
            position: relative;
            border-radius: 2px 2px 0 0;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        #pointer-arrow::before {
            content: '';
            position: absolute;
            top: -12px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 12px solid #00ff00;
        }

        #pointer-info {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            text-align: center;
            margin-top: 5px;
        }

        #error-message {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(255, 0, 0, 0.9);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            z-index: 30;
            display: none;
        }

        #debug-log {
            position: fixed;
            bottom: 60px;
            left: 10px;
            right: 10px;
            max-height: 150px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ff00;
            padding: 10px;
            border-radius: 5px;
            font-size: 9px;
            font-family: monospace;
            overflow-y: auto;
            z-index: 25;
            display: none;
        }

        #debug-log.visible {
            display: block;
        }

        #toggle-debug {
            position: fixed;
            bottom: 20px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 10px;
            z-index: 26;
            cursor: pointer;
            border: 1px solid #00ff00;
        }

        #toggle-markers {
            position: fixed;
            bottom: 70px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 10px;
            z-index: 26;
            cursor: pointer;
            border: 1px solid #00ffff;
        }

        .marker-highlight {
            position: absolute;
            border: 3px solid #00ff00;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
            pointer-events: none;
            z-index: 15;
        }

        /* Direction Compass */
        #direction-compass {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            pointer-events: none;
            z-index: 20;
            display: none;
        }

        #direction-compass.visible {
            display: block;
        }

        .compass-circle {
            position: absolute;
            width: 100%;
            height: 100%;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        .compass-arrow {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            transform-origin: 0 0;
            transition: transform 0.3s ease-out;
        }

        .compass-arrow::before {
            content: '‚ñ≤';
            position: absolute;
            font-size: 40px;
            color: #4CAF50;
            text-shadow: 0 0 10px rgba(76, 175, 80, 0.8);
            transform: translate(-50%, -100%);
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: translate(-50%, -100%) scale(1); }
            50% { opacity: 0.6; transform: translate(-50%, -100%) scale(1.2); }
        }

        .compass-label {
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(76, 175, 80, 0.9);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            white-space: nowrap;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .compass-distance {
            position: absolute;
            bottom: -35px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.7);
        }

        #marker-debug-overlay {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 8px;
            font-size: 11px;
            font-family: monospace;
            z-index: 30;
            display: none;
            max-width: 300px;
        }

        #marker-debug-overlay.visible {
            display: block;
        }

        .debug-marker-item {
            margin: 5px 0;
            padding: 5px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        .debug-marker-detection {
            color: #00ff00;
            font-weight: bold;
        }

        .debug-marker-positioning {
            color: #00ffff;
            font-weight: bold;
        }

        .debug-marker-anchor {
            color: #ffaa00;
            font-weight: bold;
        }

        @media (max-width: 768px) {
            #controls {
                flex-direction: column;
                align-items: stretch;
            }

            .info-panel {
                margin: 2px 0;
            }
        }
    </style>
</head>
<body>
    <div id="camera-container">
        <video id="camera-stream" autoplay playsinline></video>
        <div id="ar-overlay"></div>

        <!-- Direction Compass -->
        <div id="direction-compass">
            <div class="compass-circle"></div>
            <div class="compass-label" id="compass-label">Gira il telefono</div>
            <div class="compass-arrow" id="compass-arrow"></div>
            <div class="compass-distance" id="compass-distance"></div>
        </div>
    </div>

    <div id="controls">
        <div class="info-panel">
            <div class="info-title">GPS</div>
            <div class="info-value" id="gps-coords">Caricamento...</div>
        </div>

        <div class="info-panel">
            <div class="info-title">Accuracy</div>
            <div class="info-value" id="gps-accuracy">-</div>
        </div>

        <div class="info-panel">
            <div class="info-title">Altitude</div>
            <div class="info-value" id="gps-altitude">-</div>
        </div>

        <div class="info-panel">
            <div class="info-title">Nearest</div>
            <div class="info-value" id="nearest-distance">-</div>
        </div>

        <div class="info-panel">
            <div class="info-title">Compass</div>
            <div class="info-value" id="compass-status">OFF</div>
        </div>

        <div class="info-panel">
            <div class="info-title">Characters</div>
            <div class="info-value" id="character-count">{{ characters.count }}</div>
        </div>

        <div class="info-panel">
            <div class="info-title">Marker</div>
            <div class="info-value" id="marker-status">-</div>
        </div>
    </div>

    <div id="character-pointer">
        <div id="pointer-arrow"></div>
        <div id="pointer-info">
            <div id="pointer-name">-</div>
            <div id="pointer-distance">-</div>
        </div>
    </div>

    <div id="compass-button" style="position: fixed; bottom: 20px; right: 20px; background: rgba(0,0,0,0.7); color: white; padding: 10px 15px; border-radius: 5px; border: none; font-size: 12px; z-index: 25; cursor: pointer;">
        Enable Compass
    </div>

    <div id="error-message"></div>
    <button id="toggle-debug" onclick="toggleDebugLog()">üêõ Debug</button>
    <button id="toggle-markers" onclick="toggleMarkers()">üëÅÔ∏è Hide Markers</button>
    <div id="debug-log"></div>

    <!-- Marker Detection Debug Overlay -->
    <div id="marker-debug-overlay">
        <div style="font-weight: bold; margin-bottom: 8px; border-bottom: 1px solid #444; padding-bottom: 5px;">
            üìç Marker Detection Status
        </div>
        <div id="marker-debug-content">
            <div style="color: #888;">Waiting for detection...</div>
        </div>
    </div>
    <button id="toggle-marker-debug" onclick="toggleMarkerDebug()"
            style="position: fixed; bottom: 70px; left: 10px; background: rgba(0, 0, 0, 0.7); color: white; padding: 8px 12px; border-radius: 5px; font-size: 10px; z-index: 26; cursor: pointer; border: 1px solid #ff00ff;">
        üéØ Marker Info
    </button>

    <script>
        // Inizializza stato marker PRIMA di tutto (default: visibili)
        window.markersVisible = true;

        function toggleDebugLog() {
            const log = document.getElementById('debug-log');
            log.classList.toggle('visible');
        }

        function toggleMarkers() {
            window.markersVisible = !window.markersVisible;
            updateMarkersButton();

            // Mostra/nascondi immediatamente tutti i marker esistenti
            document.querySelectorAll('.marker-highlight, .keypoint-marker').forEach(el => {
                el.style.display = window.markersVisible ? 'block' : 'none';
            });

            console.log(`Markers visibility: ${window.markersVisible ? 'ON' : 'OFF'}`);
        }

        function toggleMarkerDebug() {
            const overlay = document.getElementById('marker-debug-overlay');
            overlay.classList.toggle('visible');
        }

        function updateMarkersButton() {
            const button = document.getElementById('toggle-markers');
            if (window.markersVisible) {
                button.textContent = 'üëÅÔ∏è Hide Markers';
                button.style.borderColor = '#00ff00';
            } else {
                button.textContent = 'üëÅÔ∏è Show Markers';
                button.style.borderColor = '#ff0000';
            }
        }

        // Imposta label iniziale al caricamento
        window.addEventListener('DOMContentLoaded', () => {
            updateMarkersButton();
        });
    </script>

    <script>
        // Debug logger che mostra i log sullo schermo
        const debugLog = [];
        const originalConsoleLog = console.log;
        const originalConsoleError = console.error;

        function updateDebugDisplay() {
            const debugDiv = document.getElementById('debug-log');
            if (debugDiv) {
                debugDiv.innerHTML = debugLog.slice(-10).join('<br>');
                debugDiv.scrollTop = debugDiv.scrollHeight;
            }
        }

        console.log = function(...args) {
            originalConsoleLog.apply(console, args);
            debugLog.push(`[LOG] ${args.join(' ')}`);
            updateDebugDisplay();
        };

        console.error = function(...args) {
            originalConsoleError.apply(console, args);
            debugLog.push(`[ERR] ${args.join(' ')}`);
            updateDebugDisplay();
        };
    </script>

    <script>
        // EMBEDDED CHARACTER DATA (pre-loaded dal server - zero latency)
        window.EMBEDDED_CHARACTERS = {{ characters_json|safe }};
        console.log('‚úÖ Embedded character data loaded:', window.EMBEDDED_CHARACTERS.length, 'characters');
    </script>

    <script>
        // Global flag per OpenCV
        let openCvReady = false;
        function onOpenCvReady() {
            openCvReady = true;
            console.log('‚úÖ OpenCV.js loaded successfully');
            const markerStatus = document.getElementById('marker-status');
            if (markerStatus) {
                markerStatus.textContent = 'Loading...';
                markerStatus.style.color = '#00ff00';
            }
        }

        // Inizializza status
        window.addEventListener('DOMContentLoaded', () => {
            const markerStatus = document.getElementById('marker-status');
            if (markerStatus) {
                markerStatus.textContent = 'Loading OpenCV...';
                markerStatus.style.color = '#ffff00';
            }
        });

        // Kalman Filter per smoothing sensori
        class KalmanFilter {
            constructor(processNoise = 0.01, measurementNoise = 0.1, initialEstimate = 0) {
                this.q = processNoise;      // Process noise covariance
                this.r = measurementNoise;  // Measurement noise covariance
                this.p = 1.0;               // Estimation error covariance
                this.x = initialEstimate;   // State estimate
                this.k = 0;                 // Kalman gain
            }

            filter(measurement) {
                // Prediction step
                this.p = this.p + this.q;

                // Update step
                this.k = this.p / (this.p + this.r);
                this.x = this.x + this.k * (measurement - this.x);
                this.p = (1 - this.k) * this.p;

                return this.x;
            }

            reset(value) {
                this.x = value;
                this.p = 1.0;
            }
        }

        class ARCamera {
            constructor() {
                this.currentPosition = null;
                this.currentHeading = 0;
                this.characters = [];
                this.activeCharacters = [];
                this.nearestCharacter = null;
                this.lastUpdate = 0;
                this.markerDetector = null;
                this.detectedMarkers = new Map(); // marker_id -> position
                this.videoElement = null;

                // Stabilizzazione e smoothing
                this.characterStates = new Map(); // charId -> { visible, lastSeen, position, positionHistory, kalmanX, kalmanY }
                this.PERSISTENCE_FRAMES = 5; // Mantieni visibile per N frames dopo perdita marker
                this.POSITION_HISTORY_SIZE = 2; // Media mobile su N posizioni (ridotto per reattivit√†)
                this.HYSTERESIS_SHOW = 50; // Soglia detection marker per cercare positioning marker (bilanciata per evitare false positive)
                this.HYSTERESIS_HIDE = 40; // Soglia per nascondere (con hysteresis di 10 per stabilit√†)
                this.OUTLIER_THRESHOLD = 1.8; // Soglia outlier: 180% distanza media
                this.EMA_ALPHA = 0.7; // AUMENTATO: Peso per EMA smoothing (0=smooth, 1=reattivo) - pi√π reattivo

                // Kalman filters per smoothing sensori
                // GPS: process noise basso (cambia lentamente), measurement noise alto (GPS inaccurato)
                this.gpsLatFilter = new KalmanFilter(0.001, 0.5);
                this.gpsLngFilter = new KalmanFilter(0.001, 0.5);
                // Compass: process noise medio (pu√≤ cambiare velocemente), measurement noise medio-alto
                this.headingFilter = new KalmanFilter(0.05, 0.3);
                this.headingInitialized = false;

                // Orientamento dispositivo (tilt)
                this.currentBeta = 0;  // Pitch (inclinazione avanti/indietro)
                this.currentGamma = 0; // Roll (inclinazione sinistra/destra)
                this.screenOrientation = 'portrait'; // portrait | landscape

                // Ancoraggi 3D persistenti per positioning markers (coordinate VIDEO space)
                this.positionAnchors = new Map(); // charId -> { videoX, videoY, bearing, distance, gpsLat, gpsLng, heading, beta, gamma, createdAt, lastUpdate }

                // Sistema di interpolazione per movimenti fluidi
                this.characterSmoothPositions = new Map(); // charId -> { currentX, currentY, currentScale, targetX, targetY, targetScale, lastUpdate }
                this.smoothingFactor = 0.15; // Velocit√† interpolazione (0.1 = lento, 0.3 = veloce)

                this.initCamera();
                this.initGPS();
                this.loadCharacterData();
                this.setupCompassButton();
                this.initMarkerDetection();
                this.autoEnableCompass();
                this.startSmoothPositionLoop(); // Loop per interpolazione continua
            }

            async initCamera() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            facingMode: 'environment',
                            width: { ideal: 1920 },
                            height: { ideal: 1080 }
                        }
                    });
                    this.videoElement = document.getElementById('camera-stream');
                    this.videoElement.srcObject = stream;
                } catch (error) {
                    this.showError('Errore accesso fotocamera: ' + error.message);
                }
            }

            async initMarkerDetection() {
                console.log('Initializing marker detection...');

                // Aspetta che OpenCV sia pronto
                const waitForOpenCV = setInterval(() => {
                    if (openCvReady) {
                        clearInterval(waitForOpenCV);
                        console.log('‚úÖ OpenCV.js ready - initializing marker detection');
                        this.loadMarkerImages();
                        this.startMarkerDetectionLoop();
                    }
                }, 100);

                // Timeout dopo 30 secondi (OpenCV √® pesante su mobile)
                setTimeout(() => {
                    clearInterval(waitForOpenCV);
                    if (!openCvReady) {
                        console.error('‚ùå OpenCV.js failed to load after 30s - marker detection disabled');
                        console.error('Possible causes: slow connection, mobile browser compatibility, CORS issue');
                        const markerStatus = document.getElementById('marker-status');
                        markerStatus.textContent = 'OpenCV timeout (GPS only)';
                        markerStatus.style.color = '#ff9900';
                        // Continua con solo GPS
                    }
                }, 30000);
            }

            async loadMarkerImages() {
                console.log(`Loading marker images for ${this.characters.length} characters...`);

                // Aspetta che OpenCV sia completamente pronto
                await new Promise(resolve => setTimeout(resolve, 500));

                // Carica i detection markers e positioning markers
                this.markerTemplates = new Map();
                this.positioningMarkerTemplates = new Map();
                let totalFeatures = 0;

                for (const char of this.characters) {
                    console.log(`Checking character: ${char.name}, use_marker: ${char.use_marker}, marker_image: ${char.marker_image}`);
                    if (char.use_marker && char.marker_image) {
                        try {
                            // DETECTION MARKER - decide SE mostrare il character
                            const img = await this.loadImage(char.marker_image);

                            // Doppio controllo che cv sia pronto
                            if (!cv || !cv.imread) {
                                throw new Error('OpenCV imread not ready');
                            }

                            const mat = cv.imread(img);
                            const gray = new cv.Mat();
                            cv.cvtColor(mat, gray, cv.COLOR_RGBA2GRAY);

                            // Estrai features (500 funziona meglio su iOS)
                            const orb = new cv.ORB(500);
                            const keypoints = new cv.KeyPointVector();
                            const descriptors = new cv.Mat();
                            orb.detectAndCompute(gray, new cv.Mat(), keypoints, descriptors);

                            const featureCount = keypoints.size();
                            totalFeatures += featureCount;

                            this.markerTemplates.set(char.id, {
                                character: char,
                                keypoints: keypoints,
                                descriptors: descriptors,
                                width: mat.cols,
                                height: mat.rows,
                                featureCount: featureCount,
                                type: 'detection'
                            });

                            mat.delete();
                            gray.delete();
                            console.log(`Loaded detection marker for ${char.name}: ${featureCount} features`);

                            // POSITIONING MARKER - decide DOVE posizionare il character (opzionale)
                            if (char.positioning_marker_image) {
                                const posImg = await this.loadImage(char.positioning_marker_image);
                                const posMat = cv.imread(posImg);
                                const posGray = new cv.Mat();
                                cv.cvtColor(posMat, posGray, cv.COLOR_RGBA2GRAY);

                                // Aumentato a 2000 features per maggiore precisione nel positioning
                                const posOrb = new cv.ORB(2000);
                                const posKeypoints = new cv.KeyPointVector();
                                const posDescriptors = new cv.Mat();
                                posOrb.detectAndCompute(posGray, new cv.Mat(), posKeypoints, posDescriptors);

                                const posFeatureCount = posKeypoints.size();

                                this.positioningMarkerTemplates.set(char.id, {
                                    character: char,
                                    keypoints: posKeypoints,
                                    descriptors: posDescriptors,
                                    width: posMat.cols,
                                    height: posMat.rows,
                                    featureCount: posFeatureCount,
                                    type: 'positioning'
                                });

                                posMat.delete();
                                posGray.delete();
                                console.log(`Loaded positioning marker for ${char.name}: ${posFeatureCount} features`);
                            }
                        } catch (error) {
                            console.log(`Failed to load marker for ${char.name}:`, error);
                        }
                    }
                }

                // Aggiorna UI con info sui marker caricati
                const markerStatus = document.getElementById('marker-status');
                if (this.markerTemplates.size > 0) {
                    markerStatus.textContent = `${this.markerTemplates.size}D/${this.positioningMarkerTemplates.size}P loaded`;
                    markerStatus.style.color = '#00ff00';
                } else {
                    markerStatus.textContent = 'None';
                    markerStatus.style.color = '#ff9900';
                }
            }

            loadImage(url) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => resolve(img);
                    img.onerror = reject;
                    img.src = url;
                });
            }

            startMarkerDetectionLoop() {
                // Canvas nascosto per processing
                this.processingCanvas = document.createElement('canvas');
                this.processingCtx = this.processingCanvas.getContext('2d');

                // Esegui detection ogni 150ms per tracking pi√π fluido (era 500ms)
                setInterval(() => {
                    if (openCvReady && this.videoElement && this.videoElement.readyState === 4 && this.markerTemplates.size > 0) {
                        this.detectMarkersInFrame();
                    }
                }, 150);
            }

            startSmoothPositionLoop() {
                // Loop di rendering a 60fps per interpolazione posizioni
                const updateLoop = () => {
                    this.updateSmoothPositions();
                    this.updateAnchoredCharacters(); // Aggiorna anche character ancorati
                    this.updateDirectionCompass(); // Aggiorna bussola direzionale
                    requestAnimationFrame(updateLoop);
                };
                requestAnimationFrame(updateLoop);
            }

            updateAnchoredCharacters() {
                // Aggiorna posizioni di character con anchor in base a movimenti camera
                if (!this.currentPosition || !this.positionAnchors.size) return;

                const overlay = document.getElementById('ar-overlay');
                if (!overlay) return;

                const now = Date.now();
                const ANCHOR_TIMEOUT = 10000; // 10 secondi senza marker detection = cancella anchor

                this.positionAnchors.forEach((anchor, charId) => {
                    const character = this.characters.find(c => c.id === charId);
                    if (!character) return;

                    // Se marker detection perso da troppo tempo, cancella anchor
                    const hasDetectionMarker = this.detectedMarkers.has(charId);
                    if (!hasDetectionMarker && (now - anchor.lastUpdate) > ANCHOR_TIMEOUT) {
                        this.positionAnchors.delete(charId);
                        const characterDiv = overlay.querySelector(`[data-character-id="${charId}"]`);
                        if (characterDiv) {
                            characterDiv.style.opacity = '0';
                        }
                        console.log(`üóëÔ∏è Anchor deleted for ${character.name}: no marker detection for ${ANCHOR_TIMEOUT/1000}s`);
                        return;
                    }

                    // Calcola nuova posizione schermo dall'anchor
                    const screenPosition = this.calculateAnchoredPosition(anchor, character);

                    const characterDiv = overlay.querySelector(`[data-character-id="${charId}"]`);
                    if (!characterDiv) return;

                    if (screenPosition && screenPosition.visible) {
                        // Aggiorna TARGET position per interpolazione smooth
                        let smoothPos = this.characterSmoothPositions.get(charId);
                        if (smoothPos) {
                            smoothPos.targetX = screenPosition.x;
                            smoothPos.targetY = screenPosition.y;
                            smoothPos.targetScale = screenPosition.scale;
                        }
                        // Mostra personaggio se nascosto
                        if (characterDiv.style.opacity === '0') {
                            characterDiv.style.opacity = '1';
                        }
                    } else {
                        // Fuori FOV - nascondi personaggio
                        if (characterDiv.style.opacity !== '0') {
                            characterDiv.style.opacity = '0';
                        }
                    }
                });
            }

            updateDirectionCompass() {
                // Mostra bussola per character fuori FOV
                const compass = document.getElementById('direction-compass');
                if (!compass || !this.currentPosition) return;

                // Trova il character pi√π vicino fuori FOV
                let closestOutOfView = null;
                let closestDistance = Infinity;

                this.characters.forEach(character => {
                    // Salta character gi√† visibili
                    const charDiv = document.querySelector(`[data-character-id="${character.id}"]`);
                    if (charDiv && charDiv.style.opacity !== '0') return;

                    // Calcola distanza e bearing
                    const distance = this.calculateDistance(
                        this.currentPosition.coords.latitude,
                        this.currentPosition.coords.longitude,
                        character.target_latitude,
                        character.target_longitude
                    );

                    // Solo se dentro activation_distance
                    if (distance < character.activation_distance && distance < closestDistance) {
                        const bearing = this.calculateBearing(
                            this.currentPosition.coords.latitude,
                            this.currentPosition.coords.longitude,
                            character.target_latitude,
                            character.target_longitude
                        );

                        closestDistance = distance;
                        closestOutOfView = {
                            character: character,
                            distance: distance,
                            bearing: bearing
                        };
                    }
                });

                if (closestOutOfView) {
                    // Mostra bussola
                    compass.classList.add('visible');

                    // Calcola angolo relativo alla camera
                    let relativeBearing = (closestOutOfView.bearing - this.currentHeading + 360) % 360;
                    if (relativeBearing > 180) {
                        relativeBearing -= 360;
                    }

                    // Aggiorna freccia
                    const arrow = document.getElementById('compass-arrow');
                    arrow.style.transform = `rotate(${relativeBearing}deg)`;

                    // Aggiorna label
                    const label = document.getElementById('compass-label');
                    const directionText = this.getDirectionText(relativeBearing);
                    label.textContent = `${closestOutOfView.character.name} ${directionText}`;

                    // Aggiorna distanza
                    const distanceEl = document.getElementById('compass-distance');
                    distanceEl.textContent = `${Math.round(closestOutOfView.distance)}m`;
                } else {
                    // Nascondi bussola
                    compass.classList.remove('visible');
                }
            }

            getDirectionText(angle) {
                // Converti angolo in testo direzionale
                const absAngle = Math.abs(angle);
                if (absAngle < 15) return '‚Üë Davanti';
                if (absAngle > 165) return '‚Üì Dietro';
                if (angle > 0) {
                    if (angle < 80) return '‚Üó Destra';
                    if (angle < 100) return '‚Üí Destra';
                    return '‚Üò Destra Dietro';
                } else {
                    if (angle > -80) return '‚Üñ Sinistra';
                    if (angle > -100) return '‚Üê Sinistra';
                    return '‚Üô Sinistra Dietro';
                }
            }

            updateSmoothPositions() {
                // Interpola posizioni di tutti i character visibili
                const overlay = document.getElementById('ar-overlay');
                if (!overlay) return;

                const allCharDivs = overlay.querySelectorAll('.ar-character');

                allCharDivs.forEach(div => {
                    const charId = parseInt(div.dataset.characterId);
                    const smoothPos = this.characterSmoothPositions.get(charId);

                    if (smoothPos && smoothPos.targetX !== null) {
                        // Interpolazione lineare (LERP)
                        const oldX = smoothPos.currentX;
                        smoothPos.currentX += (smoothPos.targetX - smoothPos.currentX) * this.smoothingFactor;
                        smoothPos.currentY += (smoothPos.targetY - smoothPos.currentY) * this.smoothingFactor;
                        smoothPos.currentScale += (smoothPos.targetScale - smoothPos.currentScale) * this.smoothingFactor;

                        // Debug: log solo se c'√® movimento significativo
                        const deltaX = Math.abs(smoothPos.currentX - oldX);
                        if (deltaX > 1) {
                            console.log(`üîÑ Interpolating char ${charId}: target=(${smoothPos.targetX.toFixed(0)},${smoothPos.targetY.toFixed(0)}) current=(${smoothPos.currentX.toFixed(0)},${smoothPos.currentY.toFixed(0)})`);
                        }

                        // Applica posizione interpolata
                        div.style.left = `${smoothPos.currentX}px`;
                        div.style.top = `${smoothPos.currentY}px`;

                        const baseSize = 80;
                        const imgSize = baseSize * smoothPos.currentScale;
                        const img = div.querySelector('img');
                        if (img) {
                            img.style.width = `${imgSize}px`;
                            img.style.height = `${imgSize}px`;
                        }
                    }
                });
            }

            detectMarkersInFrame() {
                try {
                    if (!this.currentPosition) {
                        console.log('No GPS position available for marker detection');
                        return;
                    }

                    // STEP 1: Trova character PI√ô VICINO (senza anchor)
                    let nearestChar = null;
                    let nearestDistance = Infinity;

                    for (const [charId, template] of this.markerTemplates) {
                        const character = template.character;
                        const distance = this.calculateDistance(
                            this.currentPosition.coords.latitude,
                            this.currentPosition.coords.longitude,
                            character.target_latitude,
                            character.target_longitude
                        );

                        // Fuori area ‚Üí rimuovi anchor
                        if (distance > character.activation_distance) {
                            if (this.positionAnchors.has(charId)) {
                                this.positionAnchors.delete(charId);
                                console.log(`üîì Anchor removed for ${character.name}: outside area`);
                            }
                            continue;
                        }

                        // Trova il pi√π vicino SENZA anchor
                        if (!this.positionAnchors.has(charId) && distance < nearestDistance) {
                            nearestDistance = distance;
                            nearestChar = { charId, template, character, distance };
                        }
                    }

                    // STEP 2: Se tutti hanno anchor ‚Üí SKIP scan ma aggiorna overlay
                    if (!nearestChar) {
                        if (this.positionAnchors.size > 0) {
                            console.log(`‚öì All ${this.positionAnchors.size} characters anchored - SKIP scan`);
                            this.updateAROverlay(); // Aggiorna posizione da anchor
                        }
                        return;
                    }

                    // DEBUG: Verifica stato anchor
                    const hasAnchor = this.positionAnchors.has(nearestChar.charId);
                    console.log(`üéØ Scan nearest: ${nearestChar.character.name} (${Math.round(nearestDistance)}m) - Anchor: ${hasAnchor ? 'YES' : 'NO'}`);

                    // STEP 3: Processa SOLO character pi√π vicino
                    this.processingCanvas.width = this.videoElement.videoWidth;
                    this.processingCanvas.height = this.videoElement.videoHeight;
                    this.processingCtx.drawImage(this.videoElement, 0, 0);

                    const src = cv.imread(this.processingCanvas);
                    const gray = new cv.Mat();
                    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

                    // ORB features adattivo in base a distanza
                    // Vicino (< 5m): meno features (marker pi√π grande)
                    // Lontano (> 20m): pi√π features (marker pi√π piccolo)
                    const adaptiveFeatures = this.getAdaptiveORBFeatures(nearestDistance);
                    const orb = new cv.ORB(adaptiveFeatures);
                    const keypoints = new cv.KeyPointVector();
                    const descriptors = new cv.Mat();
                    orb.detectAndCompute(gray, new cv.Mat(), keypoints, descriptors);

                    console.log(`üîç ORB detection: ${adaptiveFeatures} features for distance ${Math.round(nearestDistance)}m`);

                    this.detectedMarkers.clear();
                    this.detectedPositioningMarkers = this.detectedPositioningMarkers || new Map();
                    this.detectedPositioningMarkers.clear();

                    // Usa solo character pi√π vicino
                    const charId = nearestChar.charId;
                    const template = nearestChar.template;
                    const character = nearestChar.character;
                    const distance = nearestChar.distance;

                    const matches = this.matchFeatures(descriptors, template.descriptors, keypoints, template.keypoints);

                    // DETECTION MARKER: Salva sempre i dati per visualizzare keypoints
                    if (matches.length > 0) {
                            // FILTRO OUTLIERS anche per detection marker
                            // Prima passata: calcola centro grezzo
                            let tempCenterX = 0, tempCenterY = 0;
                            const allDetectionKeypoints = [];

                            matches.forEach(m => {
                                const kp = keypoints.get(m.queryIdx);
                                tempCenterX += kp.pt.x;
                                tempCenterY += kp.pt.y;
                                allDetectionKeypoints.push({ x: kp.pt.x, y: kp.pt.y });
                            });

                            tempCenterX /= matches.length;
                            tempCenterY /= matches.length;

                            // Calcola distanze e filtra outliers
                            const detectionDistances = allDetectionKeypoints.map(kp => {
                                const dx = kp.x - tempCenterX;
                                const dy = kp.y - tempCenterY;
                                return Math.sqrt(dx * dx + dy * dy);
                            });

                            const avgDetectionDistance = detectionDistances.reduce((sum, d) => sum + d, 0) / detectionDistances.length;
                            const maxAllowedDetectionDistance = avgDetectionDistance * this.OUTLIER_THRESHOLD;

                            // Seconda passata: usa solo keypoints filtrati
                            const matchedKeypoints = [];
                            let centerX = 0, centerY = 0;
                            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                            let filteredDetectionCount = 0;

                            allDetectionKeypoints.forEach((kp, idx) => {
                                if (detectionDistances[idx] <= maxAllowedDetectionDistance) {
                                    centerX += kp.x;
                                    centerY += kp.y;
                                    minX = Math.min(minX, kp.x);
                                    minY = Math.min(minY, kp.y);
                                    maxX = Math.max(maxX, kp.x);
                                    maxY = Math.max(maxY, kp.y);
                                    matchedKeypoints.push({ x: kp.x, y: kp.y, type: 'detection' });
                                    filteredDetectionCount++;
                                }
                            });

                            // Fallback se troppi filtrati
                            if (filteredDetectionCount < matches.length * 0.3) {
                                centerX = tempCenterX;
                                centerY = tempCenterY;
                                minX = Math.min(...allDetectionKeypoints.map(kp => kp.x));
                                minY = Math.min(...allDetectionKeypoints.map(kp => kp.y));
                                maxX = Math.max(...allDetectionKeypoints.map(kp => kp.x));
                                maxY = Math.max(...allDetectionKeypoints.map(kp => kp.y));
                            } else {
                                centerX /= filteredDetectionCount;
                                centerY /= filteredDetectionCount;
                                console.log(`Filtered detection keypoints: ${filteredDetectionCount}/${matches.length} kept`);
                            }

                            // Padding PERCENTUALE (30% della dimensione marker) invece di fisso
                            const markerWidth = maxX - minX;
                            const markerHeight = maxY - minY;
                            const paddingPercent = 0.3; // 30% della dimensione
                            const paddingX = markerWidth * paddingPercent;
                            const paddingY = markerHeight * paddingPercent;

                            const bboxX = Math.max(0, minX - paddingX);
                            const bboxY = Math.max(0, minY - paddingY);
                            const bboxWidth = markerWidth + paddingX * 2;
                            const bboxHeight = markerHeight + paddingY * 2;

                            // ISTERESI: Soglie diverse per mostrare/nascondere (evita flickering)
                            let showCharacter = false;
                            const currentState = this.characterStates.get(charId);

                            if (currentState && currentState.visible) {
                                // Gi√† visibile: nasconde solo se scende sotto soglia bassa
                                showCharacter = matches.length >= this.HYSTERESIS_HIDE;
                            } else {
                                // Non visibile: mostra solo se supera soglia alta
                                showCharacter = matches.length >= this.HYSTERESIS_SHOW;
                            }

                            // Aggiorna stato character
                            if (!this.characterStates.has(charId)) {
                                this.characterStates.set(charId, {
                                    visible: false,
                                    lastSeen: 0,
                                    positionHistory: []
                                });
                            }

                            const state = this.characterStates.get(charId);
                            state.lastSeen = Date.now();
                            state.visible = showCharacter;

                            // Aggiungi posizione alla history per smoothing
                            state.positionHistory.push({ x: centerX, y: centerY });
                            if (state.positionHistory.length > this.POSITION_HISTORY_SIZE) {
                                state.positionHistory.shift();
                            }

                            // Calcola posizione smoothed (media mobile)
                            const smoothX = state.positionHistory.reduce((sum, p) => sum + p.x, 0) / state.positionHistory.length;
                            const smoothY = state.positionHistory.reduce((sum, p) => sum + p.y, 0) / state.positionHistory.length;

                            this.detectedMarkers.set(charId, {
                                character: template.character,
                                screenX: smoothX,
                                screenY: smoothY,
                                matches: matches.length,
                                confidence: Math.min(1.0, matches.length / 50),
                                bbox: [bboxX, bboxY, bboxWidth, bboxHeight],
                                matchedKeypoints: matchedKeypoints,
                                showCharacter: showCharacter,
                                type: 'detection'
                            });

                            console.log(`Detection marker for ${template.character.name}: ${matches.length} matches, visible=${showCharacter}`);
                            this.updateMarkerDebugOverlay(template.character.name, 'detection', matches.length, showCharacter);

                            // POSITIONING MARKER: Cerca solo se detection matches > soglia SHOW
                            if (matches.length >= this.HYSTERESIS_SHOW && this.positioningMarkerTemplates.has(charId)) {
                                console.log(`‚úÖ Detection passed threshold (${matches.length} >= ${this.HYSTERESIS_SHOW}), checking positioning marker for ${template.character.name}`);
                                const posTemplate = this.positioningMarkerTemplates.get(charId);
                                // Usa ratio test per positioning marker (pi√π preciso)
                                let posMatches = this.matchFeatures(descriptors, posTemplate.descriptors, keypoints, posTemplate.keypoints, true);
                                console.log(`üîç Positioning marker matches (ratio test): ${posMatches.length}`);

                                // HOMOGRAPHY DISABILITATO: Il ratio test (0.85) filtra gi√† abbastanza
                                // L'homography fallisce con marker frontali (det~0) bloccando l'anchor
                                // Manteniamo i match dal ratio test che sono gi√† di qualit√†
                                console.log(`‚úì Using ${posMatches.length} matches from ratio test (homography disabled for anchor stability)`)

                                if (posMatches.length > 0) {
                                    // PRIMA PASSATA: Calcola centro grezzo
                                    let tempCenterX = 0, tempCenterY = 0;
                                    const allKeypoints = [];

                                    posMatches.forEach(m => {
                                        const kp = keypoints.get(m.queryIdx);
                                        tempCenterX += kp.pt.x;
                                        tempCenterY += kp.pt.y;
                                        allKeypoints.push({ x: kp.pt.x, y: kp.pt.y });
                                    });

                                    tempCenterX /= posMatches.length;
                                    tempCenterY /= posMatches.length;

                                    // FILTRO OUTLIERS: Rimuovi keypoints troppo lontani dal centro
                                    // Calcola distanza media dal centro
                                    const distances = allKeypoints.map(kp => {
                                        const dx = kp.x - tempCenterX;
                                        const dy = kp.y - tempCenterY;
                                        return Math.sqrt(dx * dx + dy * dy);
                                    });

                                    const avgDistance = distances.reduce((sum, d) => sum + d, 0) / distances.length;
                                    const maxAllowedDistance = avgDistance * this.OUTLIER_THRESHOLD; // Soglia: 120% della distanza media

                                    // SECONDA PASSATA: Usa solo keypoints vicini al centro (rimuovi outliers)
                                    const posMatchedKeypoints = [];
                                    let posCenterX = 0, posCenterY = 0;
                                    let posMinX = Infinity, posMinY = Infinity, posMaxX = -Infinity, posMaxY = -Infinity;
                                    let filteredCount = 0;

                                    allKeypoints.forEach((kp, idx) => {
                                        if (distances[idx] <= maxAllowedDistance) {
                                            posCenterX += kp.x;
                                            posCenterY += kp.y;
                                            posMinX = Math.min(posMinX, kp.x);
                                            posMinY = Math.min(posMinY, kp.y);
                                            posMaxX = Math.max(posMaxX, kp.x);
                                            posMaxY = Math.max(posMaxY, kp.y);
                                            posMatchedKeypoints.push({ x: kp.x, y: kp.y, type: 'positioning' });
                                            filteredCount++;
                                        }
                                    });

                                    // Se troppi keypoints filtrati, usa comunque tutti (evita di perdere il marker)
                                    if (filteredCount < posMatches.length * 0.3) {
                                        console.log(`Too many outliers filtered (${filteredCount}/${posMatches.length}), using all keypoints`);
                                        posCenterX = tempCenterX;
                                        posCenterY = tempCenterY;
                                        // Ricalcola bbox con tutti i keypoints
                                        posMinX = Math.min(...allKeypoints.map(kp => kp.x));
                                        posMinY = Math.min(...allKeypoints.map(kp => kp.y));
                                        posMaxX = Math.max(...allKeypoints.map(kp => kp.x));
                                        posMaxY = Math.max(...allKeypoints.map(kp => kp.y));
                                    } else {
                                        posCenterX /= filteredCount;
                                        posCenterY /= filteredCount;
                                        console.log(`Filtered positioning keypoints: ${filteredCount}/${posMatches.length} kept (${posMatches.length - filteredCount} outliers removed)`);
                                        // Bbox gi√† calcolato solo sui keypoints filtrati (pi√π preciso)
                                    }

                                    // SMOOTHING per positioning marker (usa history separata)
                                    if (!state.positioningHistory) {
                                        state.positioningHistory = [];
                                    }
                                    state.positioningHistory.push({ x: posCenterX, y: posCenterY });
                                    if (state.positioningHistory.length > this.POSITION_HISTORY_SIZE) {
                                        state.positioningHistory.shift();
                                    }

                                    const smoothPosX = state.positioningHistory.reduce((sum, p) => sum + p.x, 0) / state.positioningHistory.length;
                                    const smoothPosY = state.positioningHistory.reduce((sum, p) => sum + p.y, 0) / state.positioningHistory.length;
                                    console.log(`üéØ Positioning marker center in VIDEO space: x=${smoothPosX.toFixed(1)}, y=${smoothPosY.toFixed(1)} (video: ${this.videoElement.videoWidth}√ó${this.videoElement.videoHeight})`);

                                    // Padding PERCENTUALE anche per positioning marker
                                    const posMarkerWidth = posMaxX - posMinX;
                                    const posMarkerHeight = posMaxY - posMinY;
                                    const posPaddingPercent = 0.3; // 30% della dimensione
                                    const posPaddingX = posMarkerWidth * posPaddingPercent;
                                    const posPaddingY = posMarkerHeight * posPaddingPercent;

                                    const posBboxX = Math.max(0, posMinX - posPaddingX);
                                    const posBboxY = Math.max(0, posMinY - posPaddingY);
                                    const posBboxWidth = posMarkerWidth + posPaddingX * 2;
                                    const posBboxHeight = posMarkerHeight + posPaddingY * 2;

                                    // Soglia positioning marker: 40+ matches necessari per anchor stabile
                                    const minPositioningMatches = 40;

                                    if (posMatches.length >= minPositioningMatches) {
                                        // Solo se abbastanza match, salva il positioning marker
                                        this.detectedPositioningMarkers.set(charId, {
                                            character: template.character,
                                            screenX: smoothPosX,
                                            screenY: smoothPosY,
                                            matches: posMatches.length,
                                            bbox: [posBboxX, posBboxY, posBboxWidth, posBboxHeight],
                                            matchedKeypoints: posMatchedKeypoints,
                                            useForPositioning: true,
                                            type: 'positioning'
                                        });
                                        console.log(`‚úì Positioning marker for ${template.character.name}: ${posMatches.length} matches`);
                                        this.updateMarkerDebugOverlay(template.character.name, 'positioning', posMatches.length, true, this.positionAnchors.has(charId));

                                        // CREA/AGGIORNA anchor con posizione PRECISA da positioning marker
                                        const bearing = this.calculateBearing(
                                            this.currentPosition.coords.latitude,
                                            this.currentPosition.coords.longitude,
                                            character.target_latitude,
                                            character.target_longitude
                                        );
                                        const distance = this.calculateDistance(
                                            this.currentPosition.coords.latitude,
                                            this.currentPosition.coords.longitude,
                                            character.target_latitude,
                                            character.target_longitude
                                        );

                                        // IMPORTANTE: Salva coordinate VIDEO (non SCREEN) per consistenza
                                        // Verranno scalate a SCREEN solo in calculateAnchoredPosition()
                                        const videoX = smoothPosX;
                                        const videoY = smoothPosY;

                                        const now = Date.now();
                                        if (this.positionAnchors.has(charId)) {
                                            // Anchor gi√† esiste ‚Üí aggiorna con blending progressivo
                                            const anchor = this.positionAnchors.get(charId);
                                            const timeSinceUpdate = now - (anchor.lastUpdate || anchor.createdAt);

                                            // Refresh progressivo: pi√π tempo passa, pi√π pesa la nuova posizione
                                            // 0-500ms: 10% nuovo, 90% vecchio (massima stabilit√†)
                                            // 500ms-2s: graduale aumento
                                            // >2s: 100% nuovo (reset completo)
                                            let blendFactor = 0.1; // Default: poca influenza nuova pos

                                            if (timeSinceUpdate > 2000) {
                                                blendFactor = 1.0; // Reset completo
                                                console.log(`üìç Anchor aged ${Math.round(timeSinceUpdate/1000)}s ‚Üí FULL REFRESH`);
                                            } else if (timeSinceUpdate > 500) {
                                                // Blend progressivo: da 0.1 a 1.0 tra 500ms e 2000ms
                                                blendFactor = 0.1 + (timeSinceUpdate - 500) / 1500 * 0.9;
                                                console.log(`üîÑ Anchor BLENDING (age: ${Math.round(timeSinceUpdate)}ms, blend: ${blendFactor.toFixed(2)})`);
                                            } else {
                                                console.log(`‚öì Anchor STABLE (${Math.round(timeSinceUpdate)}ms old)`);
                                            }

                                            // Applica blending
                                            anchor.videoX = anchor.videoX * (1 - blendFactor) + videoX * blendFactor;
                                            anchor.videoY = anchor.videoY * (1 - blendFactor) + videoY * blendFactor;
                                            anchor.bearing = anchor.bearing * (1 - blendFactor) + bearing * blendFactor;
                                            anchor.distance = anchor.distance * (1 - blendFactor) + distance * blendFactor;
                                            anchor.gpsLat = this.currentPosition.coords.latitude;
                                            anchor.gpsLng = this.currentPosition.coords.longitude;
                                            anchor.heading = this.currentHeading;
                                            anchor.beta = this.currentBeta;
                                            anchor.gamma = this.currentGamma;
                                            anchor.lastUpdate = now;
                                        } else {
                                            // Crea nuovo anchor dal positioning marker (coordinate VIDEO)
                                            this.positionAnchors.set(charId, {
                                                videoX: videoX,  // Coordinate VIDEO space
                                                videoY: videoY,
                                                bearing: bearing,
                                                distance: distance,
                                                gpsLat: this.currentPosition.coords.latitude,
                                                gpsLng: this.currentPosition.coords.longitude,
                                                heading: this.currentHeading,
                                                beta: this.currentBeta,
                                                gamma: this.currentGamma,
                                                createdAt: now,
                                                lastUpdate: now
                                            });
                                            console.log(`üîí Anchor CREATED from positioning marker for ${character.name} at ${Math.round(distance)}m (VIDEO coords: ${videoX.toFixed(1)}, ${videoY.toFixed(1)})`);
                                        }
                                    } else {
                                        // Match insufficienti ‚Üí rimuovi positioning marker dalla Map
                                        this.detectedPositioningMarkers.delete(charId);
                                        console.log(`‚ö†Ô∏è Positioning marker for ${template.character.name} removed: ${posMatches.length} < ${minPositioningMatches} matches`);
                                    }
                                }
                            }
                    }

                    // PERSISTENZA TEMPORALE: Mantieni visibili character recentemente visti
                    // MA SOLO se NON usano positioning marker (altrimenti devono seguire il marker in real-time)
                    const now = Date.now();
                    const PERSISTENCE_MS = this.PERSISTENCE_FRAMES * 500; // 500ms per frame

                    for (const [charId, state] of this.characterStates) {
                        const timeSinceLastSeen = now - state.lastSeen;
                        const character = this.characters.find(c => c.id === charId);

                        // Se il character era visibile e non √® passato troppo tempo, mantienilo visibile
                        if (state.visible && timeSinceLastSeen < PERSISTENCE_MS) {
                            if (!this.detectedMarkers.has(charId)) {
                                // Marker non rilevato questo frame

                                // SKIP persistenza se il character usa positioning marker
                                // (deve seguire il marker in tempo reale, non persistere)
                                if (character && character.positioning_marker_image) {
                                    console.log(`Skipping persistence for ${character.name}: uses positioning marker`);
                                    state.visible = false;
                                    continue;
                                }

                                // Applica persistenza solo per character senza positioning marker
                                if (character && state.positionHistory.length > 0) {
                                    const lastPos = state.positionHistory[state.positionHistory.length - 1];
                                    console.log(`Maintaining ${character.name} via persistence (${Math.round(timeSinceLastSeen)}ms ago)`);

                                    this.detectedMarkers.set(charId, {
                                        character: character,
                                        screenX: lastPos.x,
                                        screenY: lastPos.y,
                                        matches: 0,
                                        confidence: 0.5,
                                        bbox: [lastPos.x - 50, lastPos.y - 50, 100, 100],
                                        matchedKeypoints: [],
                                        showCharacter: true,
                                        type: 'persistence',
                                        isPersisted: true
                                    });
                                }
                            }
                        } else if (timeSinceLastSeen >= PERSISTENCE_MS) {
                            // Troppo tempo passato, marca come non visibile
                            state.visible = false;
                        }
                    }

                    // Aggiorna UI con status detection
                    const markerStatus = document.getElementById('marker-status');
                    if (this.detectedMarkers.size > 0) {
                        const detected = Array.from(this.detectedMarkers.values())[0];
                        const persistTag = detected.isPersisted ? ' (P)' : '';
                        markerStatus.textContent = `üü¢ ${detected.matches} matches${persistTag}`;
                        markerStatus.style.color = '#00ff00';
                    } else {
                        markerStatus.textContent = `üî¥ No matches`;
                        markerStatus.style.color = '#ff0000';
                    }

                    // Cleanup
                    src.delete();
                    gray.delete();
                    keypoints.delete();
                    descriptors.delete();

                    // Disegna i rettangoli dei marker rilevati
                    this.drawMarkerHighlights();

                    // Aggiorna overlay se ci sono marker rilevati O anchor attivi
                    if (this.detectedMarkers.size > 0 || this.positionAnchors.size > 0) {
                        this.updateAROverlay();
                    }
                } catch (error) {
                    console.log('Detection error:', error);
                }
            }

            drawMarkerHighlights() {
                // Rimuovi i vecchi highlight
                const oldHighlights = document.querySelectorAll('.marker-highlight');
                oldHighlights.forEach(h => h.remove());

                // Rimuovi i vecchi keypoint markers
                const oldKeypoints = document.querySelectorAll('.keypoint-marker');
                oldKeypoints.forEach(k => k.remove());

                // Se i marker sono nascosti, non disegnarli (default: visibili se undefined)
                if (window.markersVisible === false) {
                    return;
                }

                const scaleX = window.innerWidth / this.videoElement.videoWidth;
                const scaleY = window.innerHeight / this.videoElement.videoHeight;

                console.log(`Drawing highlights for ${this.detectedMarkers.size} detection markers`);

                // Disegna DETECTION MARKERS (verde)
                for (const [charId, marker] of this.detectedMarkers) {
                    const highlight = document.createElement('div');
                    highlight.className = 'marker-highlight';
                    highlight.style.left = (marker.bbox[0] * scaleX) + 'px';
                    highlight.style.top = (marker.bbox[1] * scaleY) + 'px';
                    highlight.style.width = (marker.bbox[2] * scaleX) + 'px';
                    highlight.style.height = (marker.bbox[3] * scaleY) + 'px';

                    // Label verde per detection
                    const label = document.createElement('div');
                    label.style.cssText = 'position: absolute; top: -20px; left: 0; background: rgba(0,255,0,0.8); color: black; padding: 2px 8px; font-size: 10px; border-radius: 3px; font-weight: bold;';
                    label.textContent = `D:${marker.matches}`;
                    highlight.appendChild(label);

                    document.getElementById('ar-overlay').appendChild(highlight);

                    // Keypoints VERDI per detection marker
                    if (marker.matchedKeypoints && marker.matchedKeypoints.length > 0) {
                        console.log(`Drawing ${marker.matchedKeypoints.length} GREEN detection keypoints`);
                        marker.matchedKeypoints.forEach(kp => {
                            const dot = document.createElement('div');
                            dot.className = 'keypoint-marker';
                            dot.style.cssText = `
                                position: fixed;
                                left: ${(kp.x * scaleX) - 3}px;
                                top: ${(kp.y * scaleY) - 3}px;
                                width: 6px;
                                height: 6px;
                                background: #00ff00;
                                border-radius: 50%;
                                box-shadow: 0 0 5px rgba(0,255,0,1);
                                pointer-events: none;
                                z-index: 9999;
                            `;
                            document.body.appendChild(dot);
                        });
                    }
                }

                // Disegna POSITIONING MARKERS (blu)
                if (this.detectedPositioningMarkers && this.detectedPositioningMarkers.size > 0) {
                    console.log(`Drawing highlights for ${this.detectedPositioningMarkers.size} positioning markers`);

                    for (const [charId, marker] of this.detectedPositioningMarkers) {
                        const highlight = document.createElement('div');
                        highlight.className = 'marker-highlight';
                        highlight.style.cssText = `
                            position: absolute;
                            left: ${marker.bbox[0] * scaleX}px;
                            top: ${marker.bbox[1] * scaleY}px;
                            width: ${marker.bbox[2] * scaleX}px;
                            height: ${marker.bbox[3] * scaleY}px;
                            border: 2px solid #00aaff;
                            box-shadow: 0 0 10px rgba(0,170,255,0.5);
                            pointer-events: none;
                        `;

                        // Label blu per positioning
                        const label = document.createElement('div');
                        label.style.cssText = 'position: absolute; top: -20px; right: 0; background: rgba(0,170,255,0.8); color: black; padding: 2px 8px; font-size: 10px; border-radius: 3px; font-weight: bold;';
                        label.textContent = `P:${marker.matches}`;
                        highlight.appendChild(label);

                        document.getElementById('ar-overlay').appendChild(highlight);

                        // Keypoints BLU per positioning marker
                        if (marker.matchedKeypoints && marker.matchedKeypoints.length > 0) {
                            console.log(`Drawing ${marker.matchedKeypoints.length} BLUE positioning keypoints`);
                            marker.matchedKeypoints.forEach(kp => {
                                const dot = document.createElement('div');
                                dot.className = 'keypoint-marker';
                                dot.style.cssText = `
                                    position: fixed;
                                    left: ${(kp.x * scaleX) - 3}px;
                                    top: ${(kp.y * scaleY) - 3}px;
                                    width: 6px;
                                    height: 6px;
                                    background: #00aaff;
                                    border-radius: 50%;
                                    box-shadow: 0 0 5px rgba(0,170,255,1);
                                    pointer-events: none;
                                    z-index: 9999;
                                `;
                                document.body.appendChild(dot);
                            });
                        }
                    }
                }
            }

            matchFeatures(desc1, desc2, keypoints1, keypoints2, useRatioTest = false) {
                if (!desc1 || !desc2 || desc1.rows === 0 || desc2.rows === 0) {
                    return [];
                }

                if (useRatioTest) {
                    // Ratio test di Lowe (pi√π accurato per positioning marker)
                    const bf = new cv.BFMatcher(cv.NORM_HAMMING, false); // crossCheck=false per knnMatch
                    const matches = new cv.DMatchVectorVector();
                    bf.knnMatch(desc1, desc2, matches, 2); // Trova i 2 migliori match

                    const goodMatches = [];
                    const ratioThreshold = 0.85; // Soglia rilassata (85%) per positioning marker

                    for (let i = 0; i < matches.size(); i++) {
                        const match = matches.get(i);
                        if (match.size() >= 2) {
                            const m1 = match.get(0);
                            const m2 = match.get(1);
                            // Ratio test: primo match deve essere migliore del secondo
                            if (m1.distance < ratioThreshold * m2.distance && m1.distance < 70) {
                                goodMatches.push(m1);
                            }
                        } else if (match.size() === 1) {
                            const m = match.get(0);
                            if (m.distance < 70) {
                                goodMatches.push(m);
                            }
                        }
                    }

                    matches.delete();
                    return goodMatches;
                } else {
                    // Matching semplice con threshold (per detection marker)
                    const bf = new cv.BFMatcher(cv.NORM_HAMMING, true);
                    const matches = new cv.DMatchVector();
                    bf.match(desc1, desc2, matches);

                    const goodMatches = [];
                    for (let i = 0; i < matches.size(); i++) {
                        const match = matches.get(i);
                        if (match.distance < 70) { // Soglia permissiva per detection
                            goodMatches.push(match);
                        }
                    }

                    matches.delete();
                    return goodMatches;
                }
            }

            validateMatchesWithHomography(matches, keypointsFrame, keypointsTemplate) {
                try {
                    if (matches.length < 10) {
                        return matches; // Troppo pochi match per calcolare homography
                    }

                    // Estrai coordinate dei match
                    const srcPoints = [];
                    const dstPoints = [];

                    matches.forEach(m => {
                        const kpFrame = keypointsFrame.get(m.queryIdx);
                        const kpTemplate = keypointsTemplate.get(m.trainIdx);
                        srcPoints.push(kpFrame.pt.x, kpFrame.pt.y);
                        dstPoints.push(kpTemplate.pt.x, kpTemplate.pt.y);
                    });

                    const srcMat = cv.matFromArray(matches.length, 1, cv.CV_32FC2, srcPoints);
                    const dstMat = cv.matFromArray(matches.length, 1, cv.CV_32FC2, dstPoints);

                    // Calcola homography con RANSAC (rimuove outliers)
                    const H = cv.findHomography(srcMat, dstMat, cv.RANSAC, 5.0);

                    if (H.empty()) {
                        console.log('‚ö†Ô∏è Homography failed - no valid transformation found');
                        srcMat.delete();
                        dstMat.delete();
                        return []; // Nessuna trasformazione coerente trovata
                    }

                    // Verifica se homography √® valida (non degenere)
                    const det = cv.determinant(H);
                    if (Math.abs(det) < 0.01 || Math.abs(det) > 100) {
                        console.log(`‚ö†Ô∏è Homography degenerate (det=${det.toFixed(3)})`);
                        H.delete();
                        srcMat.delete();
                        dstMat.delete();
                        return []; // Trasformazione degenere
                    }

                    // Filtra match usando homography: riproietta punti e calcola errore
                    const validMatches = [];
                    for (let i = 0; i < matches.length; i++) {
                        const kpFrame = keypointsFrame.get(matches[i].queryIdx);
                        const kpTemplate = keypointsTemplate.get(matches[i].trainIdx);

                        // Proietta punto dal frame al template usando homography
                        const pt = cv.matFromArray(1, 1, cv.CV_32FC2, [kpFrame.pt.x, kpFrame.pt.y]);
                        const projected = new cv.Mat();
                        cv.perspectiveTransform(pt, projected, H);

                        const projX = projected.data32F[0];
                        const projY = projected.data32F[1];

                        // Calcola errore di riproiezione
                        const dx = projX - kpTemplate.pt.x;
                        const dy = projY - kpTemplate.pt.y;
                        const error = Math.sqrt(dx * dx + dy * dy);

                        // Accetta solo match con errore < 5 pixel
                        if (error < 5.0) {
                            validMatches.push(matches[i]);
                        }

                        pt.delete();
                        projected.delete();
                    }

                    H.delete();
                    srcMat.delete();
                    dstMat.delete();

                    return validMatches;

                } catch (error) {
                    console.log('Homography validation error:', error);
                    return matches; // Fallback: usa tutti i match
                }
            }

            initGPS() {
                if (!navigator.geolocation) {
                    this.showError('GPS non supportato su questo dispositivo');
                    return;
                }

                const options = {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 60000
                };

                navigator.geolocation.watchPosition(
                    (position) => {
                        // Applica filtro Kalman a GPS per ridurre jitter/drift
                        const rawLat = position.coords.latitude;
                        const rawLng = position.coords.longitude;

                        // Prima lettura: inizializza i filtri
                        if (!this.currentPosition) {
                            this.gpsLatFilter.reset(rawLat);
                            this.gpsLngFilter.reset(rawLng);
                        }

                        const smoothLat = this.gpsLatFilter.filter(rawLat);
                        const smoothLng = this.gpsLngFilter.filter(rawLng);

                        // Crea position object con coordinate smooth
                        this.currentPosition = {
                            coords: {
                                latitude: smoothLat,
                                longitude: smoothLng,
                                altitude: position.coords.altitude,
                                accuracy: position.coords.accuracy,
                                altitudeAccuracy: position.coords.altitudeAccuracy,
                                heading: position.coords.heading,
                                speed: position.coords.speed
                            },
                            timestamp: position.timestamp
                        };

                        console.log(`üìç GPS filtered: raw=(${rawLat.toFixed(6)}, ${rawLng.toFixed(6)}) ‚Üí smooth=(${smoothLat.toFixed(6)}, ${smoothLng.toFixed(6)})`);

                        this.updateGPSDisplay();
                        this.updateAROverlay();
                        this.updateCharacterPointer();
                    },
                    (error) => {
                        this.showError('Errore GPS: ' + error.message);
                    },
                    options
                );
            }

            setupCompassButton() {
                const button = document.getElementById('compass-button');
                button.addEventListener('click', async () => {
                    button.textContent = 'Activating...';
                    await this.initOrientation();
                });
            }

            async initOrientation() {
                try {
                    const status = document.getElementById('compass-status');

                    // Richiedi permessi per orientamento dispositivo (iOS 13+)
                    if (typeof DeviceOrientationEvent !== 'undefined' &&
                        typeof DeviceOrientationEvent.requestPermission === 'function') {

                        const permission = await DeviceOrientationEvent.requestPermission();

                        if (permission === 'granted') {
                            this.startOrientationListening();
                            status.textContent = 'ON';
                            document.getElementById('compass-button').style.display = 'none';
                        } else {
                            status.textContent = 'DENIED';
                        }
                    } else {
                        // Per Android e browser pi√π vecchi
                        this.startOrientationListening();
                        status.textContent = 'ON';
                        document.getElementById('compass-button').style.display = 'none';
                    }
                } catch (error) {
                    console.log('Errore richiesta permessi orientamento:', error);
                    document.getElementById('compass-status').textContent = 'ERROR';
                }
            }

            async autoEnableCompass() {
                // Auto-attiva compass su Android (non richiede permessi espliciti)
                // iOS richiede interazione utente tramite pulsante
                if (typeof DeviceOrientationEvent !== 'undefined') {
                    if (typeof DeviceOrientationEvent.requestPermission !== 'function') {
                        // Android o browser che non richiedono permessi ‚Üí attiva automaticamente
                        setTimeout(async () => {
                            await this.initOrientation();
                            console.log('üß≠ Compass auto-enabled (Android/non-iOS)');
                        }, 1000);
                    } else {
                        // iOS ‚Üí richiede click utente, mostra pulsante
                        console.log('üß≠ Compass requires user permission (iOS)');
                    }
                }
            }

            filterHeading(rawHeading) {
                // Gestisce heading circolare (0-360¬∞) con Kalman filter
                if (!this.headingInitialized) {
                    this.headingFilter.reset(rawHeading);
                    this.headingInitialized = true;
                    return rawHeading;
                }

                // Gestisci wraparound circolare (es. 359¬∞ ‚Üí 1¬∞ non deve smoothare a 180¬∞)
                let diff = rawHeading - this.headingFilter.x;
                if (diff > 180) diff -= 360;
                if (diff < -180) diff += 360;

                const smoothHeading = (this.headingFilter.filter(this.headingFilter.x + diff) + 360) % 360;
                return smoothHeading;
            }

            startOrientationListening() {
                if (window.DeviceOrientationEvent) {
                    // Usa deviceorientationabsolute per il nord magnetico assoluto (iOS/Android moderni)
                    window.addEventListener('deviceorientationabsolute', (event) => {
                        this.handleOrientationEvent(event);
                    });

                    // Fallback per dispositivi senza supporto assoluto
                    window.addEventListener('deviceorientation', (event) => {
                        this.handleOrientationEvent(event);
                    });

                    // Monitora cambio orientamento schermo
                    window.addEventListener('orientationchange', () => {
                        this.updateScreenOrientation();
                    });
                    this.updateScreenOrientation(); // Imposta orientamento iniziale
                } else {
                    document.getElementById('compass-status').textContent = 'NOT_SUPPORTED';
                }
            }

            handleOrientationEvent(event) {
                if (event.alpha !== null) {
                    // Alpha: heading (0-360¬∞)
                    let rawHeading = event.alpha;
                    if (event.webkitCompassHeading) {
                        rawHeading = event.webkitCompassHeading;
                    }
                    const smoothHeading = this.filterHeading(rawHeading);
                    this.currentHeading = smoothHeading;

                    // Beta: pitch (-180 a 180¬∞, avanti/indietro)
                    // 0¬∞ = telefono piatto, 90¬∞ = telefono verticale verso l'alto
                    this.currentBeta = event.beta || 0;

                    // Gamma: roll (-90 a 90¬∞, sinistra/destra)
                    // 0¬∞ = telefono piatto, 90¬∞ = telefono inclinato a destra
                    this.currentGamma = event.gamma || 0;

                    document.getElementById('compass-status').textContent =
                        `${Math.round(smoothHeading)}¬∞ Œ≤:${Math.round(this.currentBeta)}¬∞ Œ≥:${Math.round(this.currentGamma)}¬∞`;

                    this.throttledUpdatePointer();
                }
            }

            updateScreenOrientation() {
                // Determina se portrait o landscape
                const angle = window.orientation || 0;
                this.screenOrientation = (Math.abs(angle) === 90) ? 'landscape' : 'portrait';
                console.log(`Screen orientation changed: ${this.screenOrientation} (${angle}¬∞)`);
            }

            throttledUpdatePointer() {
                const now = Date.now();
                if (now - this.lastUpdate > 50) { // Aggiorna max ogni 50ms
                    this.lastUpdate = now;
                    this.updateCharacterPointer();
                }
            }

            findNearestCharacter() {
                if (!this.currentPosition || this.characters.length === 0) return null;

                let nearest = null;
                let minDistance = Infinity;

                this.characters.forEach(character => {
                    const distance = this.calculateDistance(
                        this.currentPosition.coords.latitude,
                        this.currentPosition.coords.longitude,
                        character.target_latitude,
                        character.target_longitude
                    );

                    if (distance < minDistance) {
                        minDistance = distance;
                        nearest = { ...character, distance: distance };
                    }
                });

                return nearest;
            }


            async loadCharacterData() {
                try {
                    // OTTIMIZZAZIONE: Usa dati embedded (zero latency)
                    if (window.EMBEDDED_CHARACTERS && window.EMBEDDED_CHARACTERS.length > 0) {
                        this.characters = window.EMBEDDED_CHARACTERS;
                        this.charactersLastUpdate = Date.now();
                        console.log('‚úÖ Characters loaded from embedded data (0ms latency):', this.characters.length, 'characters');
                        return;
                    }

                    // Fallback: carica da API se embedding non disponibile
                    console.log('‚ö†Ô∏è Embedded data not found, falling back to API...');
                    const response = await fetch('/api/characters/');
                    const data = await response.json();
                    this.characters = data.characters;
                    this.charactersLastUpdate = Date.now();
                    console.log('Characters loaded from API:', this.characters.length, 'characters');
                } catch (error) {
                    this.showError('Errore caricamento personaggi: ' + error.message);
                }
            }

            async refreshCharacterData() {
                // Refresh manuale dei dati (chiamato quando necessario)
                try {
                    console.log('üîÑ Refreshing character data from server...');
                    const response = await fetch('/api/characters/');
                    const data = await response.json();
                    this.characters = data.characters;
                    this.charactersLastUpdate = Date.now();

                    // Ricarica anche i marker images se cambiate
                    if (openCvReady) {
                        await this.loadMarkerImages();
                    }

                    console.log('‚úÖ Character data refreshed:', this.characters.length, 'characters');
                } catch (error) {
                    console.error('Error refreshing character data:', error);
                }
            }

            updateGPSDisplay() {
                if (this.currentPosition) {
                    const lat = this.currentPosition.coords.latitude.toFixed(6);
                    const lng = this.currentPosition.coords.longitude.toFixed(6);
                    const accuracy = Math.round(this.currentPosition.coords.accuracy);
                    const altitude = this.currentPosition.coords.altitude;

                    document.getElementById('gps-coords').textContent = `${lat}, ${lng}`;
                    document.getElementById('gps-accuracy').textContent = `¬±${accuracy}m`;

                    if (altitude !== null) {
                        document.getElementById('gps-altitude').textContent = `${Math.round(altitude)}m`;
                    } else {
                        document.getElementById('gps-altitude').textContent = 'N/A';
                    }
                }
            }

            updateCharacterPointer() {
                const nearest = this.findNearestCharacter();
                const pointer = document.getElementById('character-pointer');
                const arrow = document.getElementById('pointer-arrow');
                const nameEl = document.getElementById('pointer-name');
                const distanceEl = document.getElementById('pointer-distance');
                const nearestDistanceEl = document.getElementById('nearest-distance');

                if (nearest && this.currentPosition) {
                    // Aggiorna info nel pannello superiore
                    nearestDistanceEl.textContent = `${Math.round(nearest.distance)}m`;

                    // Calcola la direzione verso il character pi√π vicino
                    const bearing = this.calculateBearing(
                        this.currentPosition.coords.latitude,
                        this.currentPosition.coords.longitude,
                        nearest.target_latitude,
                        nearest.target_longitude
                    );

                    // Calcola la direzione relativa considerando l'orientamento del dispositivo
                    // La freccia punta nella direzione corretta relativa all'orientamento
                    const relativeBearing = (bearing - this.currentHeading + 360) % 360;

                    // Mostra il puntatore e aggiorna la direzione della freccia
                    pointer.style.display = 'block';
                    arrow.style.transform = `rotate(${relativeBearing}deg)`;
                    nameEl.textContent = nearest.name;
                    distanceEl.textContent = `${Math.round(nearest.distance)}m`;

                    // Aggiorna il character pi√π vicino
                    this.nearestCharacter = nearest;
                } else {
                    pointer.style.display = 'none';
                    nearestDistanceEl.textContent = '-';
                    this.nearestCharacter = null;
                }
            }

            updateAROverlay() {
                if (!this.currentPosition || this.characters.length === 0) return;

                const overlay = document.getElementById('ar-overlay');

                // NON cancellare tutto ogni frame - aggiorna solo le posizioni esistenti
                // Questo permette alle transizioni CSS di funzionare
                const existingCharacters = new Set();

                this.characters.forEach(character => {
                    const distance = this.calculateDistance(
                        this.currentPosition.coords.latitude,
                        this.currentPosition.coords.longitude,
                        character.target_latitude,
                        character.target_longitude
                    );

                    if (distance <= character.activation_distance) {
                        this.createOrUpdateARCharacter(character, distance);
                        existingCharacters.add(character.id);
                    }
                });

                // Rimuovi character che non sono pi√π nell'area con fade out
                const allCharDivs = overlay.querySelectorAll('.ar-character');
                allCharDivs.forEach(div => {
                    const charId = parseInt(div.dataset.characterId);
                    if (!existingCharacters.has(charId)) {
                        // Fade out prima di rimuovere
                        div.style.opacity = '0';
                        setTimeout(() => div.remove(), 300);
                    }
                });
            }

            createOrUpdateARCharacter(character, distance) {
                const overlay = document.getElementById('ar-overlay');

                // Cerca se il character esiste gi√†
                let characterDiv = overlay.querySelector(`[data-character-id="${character.id}"]`);
                const isNew = !characterDiv;

                if (isNew) {
                    characterDiv = document.createElement('div');
                    characterDiv.className = 'ar-character';
                    characterDiv.dataset.characterId = character.id;
                    characterDiv.style.opacity = '0'; // Inizia invisibile per fade in
                }

                let screenPosition;
                let scale;

                // MODALIT√Ä MARKER: Priorit√† POSITIONING MARKER real-time ‚Üí anchor fallback ‚Üí detection fallback
                if (character.use_marker) {
                    // PRIORIT√Ä 1: Positioning marker REAL-TIME (massima precisione quando visibile)
                    if (this.detectedPositioningMarkers && this.detectedPositioningMarkers.has(character.id)) {
                        const posMarker = this.detectedPositioningMarkers.get(character.id);

                        if (posMarker.useForPositioning) {
                            // Usa positioning marker coordinates (real-time tracking pixel-perfect)
                            const markerX = posMarker.screenX;
                            const markerY = posMarker.screenY;
                            const markerWidth = posMarker.bbox[2];

                            const scaleX = window.innerWidth / this.videoElement.videoWidth;
                            const scaleY = window.innerHeight / this.videoElement.videoHeight;

                            const pixelsPerMeter = markerWidth * scaleX / 0.3;

                            // Usa facing_direction per capire da che lato stai guardando il marker
                            // Se la differenza tra heading attuale e facing salvato √® ~180¬∞,
                            // stai guardando da dietro ‚Üí inverti gli offset
                            let headingDiff = 0;
                            if (this.currentHeading !== null && character.facing_direction !== null) {
                                headingDiff = Math.abs(this.currentHeading - character.facing_direction);
                                if (headingDiff > 180) headingDiff = 360 - headingDiff;
                            }

                            // Se guardi da direzione opposta (>90¬∞ di differenza), inverti offset
                            const isOppositeDirection = headingDiff > 90;
                            const xMultiplier = isOppositeDirection ? -1 : 1;
                            const zMultiplier = isOppositeDirection ? -1 : 1;

                            console.log(`üß≠ Facing check: current=${this.currentHeading?.toFixed(0)}¬∞, saved=${character.facing_direction?.toFixed(0)}¬∞, diff=${headingDiff.toFixed(0)}¬∞, opposite=${isOppositeDirection}`);

                            screenPosition = {
                                x: (markerX * scaleX) + (character.marker_offset_x * pixelsPerMeter * xMultiplier),
                                y: (markerY * scaleY) + (character.marker_offset_y * pixelsPerMeter),
                                visible: true
                            };

                            const estimatedDistance = 1.0 / (markerWidth / this.videoElement.videoWidth);
                            const targetSizeAt5m = window.innerWidth / 3;
                            const baseSize = 80;
                            const scaleAt5m = targetSizeAt5m / baseSize;
                            const baseScale = Math.max(0.2, Math.min(10, (5 / estimatedDistance) * scaleAt5m));
                            scale = baseScale * (character.base_size || 1.0);

                            console.log(`üéØ POSITIONING MARKER real-time for ${character.name}: matches=${posMarker.matches}, pos=(${Math.round(screenPosition.x)},${Math.round(screenPosition.y)}), scale=${scale.toFixed(2)}`);
                        }
                    }
                    // PRIORIT√Ä 2: Anchor FALLBACK (quando positioning marker perso ma detection OK)
                    else if (this.positionAnchors.has(character.id) && this.detectedMarkers.has(character.id)) {
                        const detectionMarker = this.detectedMarkers.get(character.id);

                        // Verifica che detection marker sia ancora valido
                        if (detectionMarker.showCharacter) {
                            const anchor = this.positionAnchors.get(character.id);

                            // Calcola posizione schermo dall'ancoraggio usando movimenti del telefono
                            screenPosition = this.calculateAnchoredPosition(anchor, character);

                            if (!screenPosition || !screenPosition.visible) {
                                // Ancoraggio fuori FOV - nascondi
                                if (!isNew && characterDiv.style.opacity !== '0') {
                                    characterDiv.style.opacity = '0';
                                    console.log(`‚öì Anchor for ${character.name} outside FOV - HIDING`);
                                }
                                return;
                            }

                            scale = screenPosition.scale;
                            console.log(`‚öì Using ANCHOR fallback for ${character.name} (positioning marker lost): pos=(${Math.round(screenPosition.x)},${Math.round(screenPosition.y)}), scale=${scale.toFixed(2)}`);
                        } else {
                            // Detection marker troppo debole
                            if (!isNew && characterDiv.style.opacity !== '0') {
                                characterDiv.style.opacity = '0';
                                console.log(`‚ùå Detection marker too weak for ${character.name} - HIDING`);
                            }
                            return;
                        }
                    }
                    // PRIORIT√Ä 3: Nessun positioning n√© anchor ‚Üí NASCONDI
                    else {
                        // Marker abilitato ma n√© positioning n√© anchor disponibili ‚Üí NASCONDI
                        if (!isNew && characterDiv.style.opacity !== '0') {
                            characterDiv.style.opacity = '0';
                            console.log(`‚ùå No positioning marker or anchor for ${character.name} - HIDING`);
                        }
                        return;
                    }
                } else {
                    // MODALIT√Ä GPS: Usa bearing e distanza normale (solo per character senza marker)
                    const bearing = this.calculateBearing(
                        this.currentPosition.coords.latitude,
                        this.currentPosition.coords.longitude,
                        character.target_latitude,
                        character.target_longitude
                    );

                    screenPosition = this.worldToScreen(bearing, distance, character);

                    // Se il personaggio √® fuori dal campo visivo, non mostrarlo
                    if (!screenPosition || !screenPosition.visible) {
                        return;
                    }

                    scale = screenPosition.scale;
                }

                // Applica la scala
                const baseSize = 80;
                const imgSize = baseSize * scale;

                // Sistema di interpolazione smooth con requestAnimationFrame
                // Aggiorna TARGET position invece di applicare direttamente
                if (!this.characterSmoothPositions.has(character.id)) {
                    this.characterSmoothPositions.set(character.id, {
                        currentX: screenPosition.x,
                        currentY: screenPosition.y,
                        currentScale: scale,
                        targetX: screenPosition.x,
                        targetY: screenPosition.y,
                        targetScale: scale,
                        lastUpdate: Date.now()
                    });
                }

                const smoothPos = this.characterSmoothPositions.get(character.id);

                // Aggiorna il TARGET (l'interpolazione avviene in updateSmoothPositions)
                smoothPos.targetX = screenPosition.x;
                smoothPos.targetY = screenPosition.y;
                smoothPos.targetScale = scale;
                smoothPos.lastUpdate = Date.now();

                // Inizializza position immediata se √® nuovo
                if (isNew) {
                    smoothPos.currentX = screenPosition.x;
                    smoothPos.currentY = screenPosition.y;
                    smoothPos.currentScale = scale;
                }

                // Usa current position per posizionamento iniziale
                console.log(`üé® Applying SMOOTHED position to DOM: raw=(${screenPosition.x.toFixed(1)}, ${screenPosition.y.toFixed(1)}) ‚Üí smooth=(${smoothPos.currentX.toFixed(1)}, ${smoothPos.currentY.toFixed(1)})`);
                // Posizionamento iniziale (l'interpolazione smooth avviene in updateSmoothPositions)
                characterDiv.style.left = smoothPos.currentX + 'px';
                characterDiv.style.top = smoothPos.currentY + 'px';
                characterDiv.style.transform = 'translate(-50%, -50%)';

                // Aggiorna contenuto solo se necessario (per evitare flickering)
                if (isNew || !characterDiv.querySelector('img')) {
                    console.log(`Character ${character.name}: distance=${Math.round(distance)}m, scale=${smoothPos.currentScale.toFixed(2)}, mode=${character.display_mode}`);
                    if (character.character_image) {
                        const currentImgSize = baseSize * smoothPos.currentScale;
                        characterDiv.innerHTML = `
                            <img src="${character.character_image}"
                                 alt="${character.name}"
                                 style="width: ${currentImgSize}px; height: ${currentImgSize}px;">
                            <div class="ar-character-info">
                                <div><strong>${character.name}</strong></div>
                                <div>${Math.round(distance)}m</div>
                            </div>
                        `;
                    } else {
                        console.log(`Character ${character.name} has no image!`);
                        return;
                    }
                } else {
                    // Aggiorna solo distanza (dimensione gestita da updateSmoothPositions)
                    const distanceDiv = characterDiv.querySelector('.ar-character-info div:last-child');
                    if (distanceDiv) {
                        distanceDiv.textContent = `${Math.round(distance)}m`;
                    }
                    // NON aggiornare img.style qui - lascia gestire a updateSmoothPositions
                }

                // Aggiungi all'overlay se nuovo
                if (isNew) {
                    overlay.appendChild(characterDiv);
                    // Fade in dopo un frame
                    setTimeout(() => {
                        characterDiv.style.opacity = '1';
                    }, 10);
                } else {
                    // Ripristina opacity per character esistenti che tornano visibili
                    if (characterDiv.style.opacity !== '1') {
                        characterDiv.style.opacity = '1';
                    }
                }
            }

            getAdaptiveORBFeatures(distance) {
                // Adatta numero di features in base alla distanza
                // Vicino: marker grande ‚Üí meno features servono
                // Lontano: marker piccolo ‚Üí pi√π features per accuratezza
                if (distance < 3) {
                    return 300; // Molto vicino
                } else if (distance < 10) {
                    return 500; // Vicino (default)
                } else if (distance < 25) {
                    return 800; // Medio-lontano
                } else {
                    return 1200; // Lontano
                }
            }

            calculateDistance(lat1, lon1, lat2, lon2) {
                const R = 6371e3; // Raggio Terra in metri
                const œÜ1 = lat1 * Math.PI/180;
                const œÜ2 = lat2 * Math.PI/180;
                const ŒîœÜ = (lat2-lat1) * Math.PI/180;
                const ŒîŒª = (lon2-lon1) * Math.PI/180;

                const a = Math.sin(ŒîœÜ/2) * Math.sin(ŒîœÜ/2) +
                        Math.cos(œÜ1) * Math.cos(œÜ2) *
                        Math.sin(ŒîŒª/2) * Math.sin(ŒîŒª/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

                return R * c;
            }

            calculateBearing(lat1, lon1, lat2, lon2) {
                const œÜ1 = lat1 * Math.PI/180;
                const œÜ2 = lat2 * Math.PI/180;
                const ŒîŒª = (lon2-lon1) * Math.PI/180;

                const y = Math.sin(ŒîŒª) * Math.cos(œÜ2);
                const x = Math.cos(œÜ1) * Math.sin(œÜ2) -
                        Math.sin(œÜ1) * Math.cos(œÜ2) * Math.cos(ŒîŒª);

                const Œ∏ = Math.atan2(y, x);

                return (Œ∏*180/Math.PI + 360) % 360;
            }

            getEffectiveFOV() {
                // FOV orizzontale della camera (tipico smartphone)
                const baseFOV = 70;

                // Aspect ratio: portrait = 9:16 (~0.56), landscape = 16:9 (~1.78)
                const aspectRatio = window.innerWidth / window.innerHeight;

                // In landscape, FOV orizzontale aumenta, in portrait diminuisce
                // Formula approssimata: FOV_eff = FOV_base * sqrt(aspect)
                const effectiveFOV = baseFOV * Math.sqrt(Math.max(0.5, Math.min(2, aspectRatio)));

                return effectiveFOV;
            }

            worldToScreen(bearing, distance, character) {
                const screenWidth = window.innerWidth;
                const screenHeight = window.innerHeight;

                // Campo visivo dinamico basato su orientamento
                const FOV = this.getEffectiveFOV();

                // Calcola il bearing relativo alla direzione della fotocamera
                let relativeBearing = (bearing - this.currentHeading + 360) % 360;

                // Normalizza il bearing tra -180 e 180 gradi
                if (relativeBearing > 180) {
                    relativeBearing -= 360;
                }

                // Controlla se il personaggio √® nel campo visivo orizzontale
                if (Math.abs(relativeBearing) > FOV / 2) {
                    // Fuori dal campo visivo - non mostrare
                    return null;
                }

                // Mappa il bearing su coordinate schermo
                // 0 gradi (davanti) = centro schermo
                // -FOV/2 = sinistra, +FOV/2 = destra
                const x = screenWidth / 2 + (relativeBearing / FOV) * screenWidth;

                // Calcola posizione verticale considerando altitudine, height_offset E tilt del telefono
                let y = screenHeight * 0.5; // Centro verticale di default

                // Compensazione tilt telefono (beta = pitch)
                // Beta: 0¬∞ = piatto, 90¬∞ = verticale, -90¬∞ = capovolto
                // Quando alzi il telefono (beta aumenta), gli oggetti devono scendere sullo schermo
                const tiltCompensation = (this.currentBeta / 90) * (screenHeight * 0.3);

                // Se abbiamo dati di altitudine GPS
                if (this.currentPosition.coords.altitude !== null && character.altitude !== 0) {
                    const altitudeDiff = character.altitude - this.currentPosition.coords.altitude + character.height_offset;
                    // Converti differenza altitudine in offset verticale (negativo = pi√π in alto)
                    const altitudeOffset = -altitudeDiff * 2; // Pixel per metro
                    y = screenHeight * 0.5 + altitudeOffset + tiltCompensation;
                } else {
                    // Fallback: usa distanza per calcolare posizione verticale
                    // Pi√π vicino = pi√π in basso (effetto prospettico)
                    const verticalOffset = Math.max(0, Math.min(1, distance / 100));

                    // Applica height_offset
                    const heightAdjustment = character.height_offset * -3; // Pixel per metro

                    if (character.display_mode === 'floating') {
                        y = screenHeight * (0.3 + verticalOffset * 0.1) + heightAdjustment + tiltCompensation;
                    } else if (character.display_mode === 'wall') {
                        y = screenHeight * 0.4 + heightAdjustment + tiltCompensation;
                    } else { // standing
                        y = screenHeight * (0.5 + verticalOffset * 0.15) + heightAdjustment + tiltCompensation;
                    }
                }

                // Calcola la scala in base alla distanza
                // A 5m = 1/3 schermo, scala proporzionale per altre distanze
                // Formula: screenWidth/3 a 5m, poi scala inversamente con distanza
                const targetSizeAt5m = screenWidth / 3; // 1/3 dello schermo a 5m
                const baseSize = 80;
                const scaleAt5m = targetSizeAt5m / baseSize; // es. 125/80 = 1.56

                // Scala inversamente proporzionale: 5m/distance * scaleAt5m
                // 1m = 5x pi√π grande, 10m = 0.5x pi√π piccolo rispetto a 5m
                const baseScale = Math.max(0.2, Math.min(10, (5 / distance) * scaleAt5m));
                const scale = baseScale * (character.base_size || 1.0);

                return {
                    x: x,
                    y: y,
                    scale: scale,
                    visible: true
                };
            }

            calculateAnchoredPosition(anchor, character) {
                // Calcola posizione schermo dall'ancoraggio 3D in base ai movimenti del telefono
                const screenWidth = window.innerWidth;
                const screenHeight = window.innerHeight;
                const FOV = this.getEffectiveFOV();

                console.log(`calculateAnchoredPosition: anchor.bearing=${anchor.bearing}, currentHeading=${this.currentHeading}, FOV=${FOV}`);

                // Calcola bearing relativo rispetto alla camera ATTUALE
                let relativeBearing = (anchor.bearing - this.currentHeading + 360) % 360;
                if (relativeBearing > 180) {
                    relativeBearing -= 360;
                }

                console.log(`relativeBearing=${relativeBearing}, FOV/2=${FOV/2}, inside=${Math.abs(relativeBearing) <= FOV/2}`);

                // Verifica se dentro FOV orizzontale
                if (Math.abs(relativeBearing) > FOV / 2) {
                    console.log(`‚ö†Ô∏è Anchor outside FOV: relativeBearing=${relativeBearing} > ${FOV/2}`);
                    return null; // Fuori campo visivo
                }

                // Posizione X dal bearing relativo
                const x = screenWidth / 2 + (relativeBearing / FOV) * screenWidth;

                // Posizione Y considerando tilt del telefono
                // Delta tilt = differenza tra inclinazione attuale e quando √® stato creato l'anchor
                const deltaBeta = this.currentBeta - anchor.beta;
                const tiltCompensation = (deltaBeta / 90) * (screenHeight * 0.3);

                // IMPORTANTE: Anchor usa coordinate VIDEO ‚Üí scala a SCREEN qui
                const scaleX = screenWidth / this.videoElement.videoWidth;
                const scaleY = screenHeight / this.videoElement.videoHeight;
                const y = (anchor.videoY * scaleY) + tiltCompensation;

                console.log(`üìê Anchor position: VIDEO=(${anchor.videoX.toFixed(1)},${anchor.videoY.toFixed(1)}) ‚Üí SCREEN=(${x.toFixed(1)},${y.toFixed(1)}) [scale=${scaleY.toFixed(3)}]`);

                // Scala basata su distanza anchor: 1/3 schermo a 5m
                const targetSizeAt5m = screenWidth / 3;
                const baseSize = 80;
                const scaleAt5m = targetSizeAt5m / baseSize;
                const baseScale = Math.max(0.2, Math.min(10, (5 / anchor.distance) * scaleAt5m));
                const scale = baseScale * (character.base_size || 1.0);

                return {
                    x: x,
                    y: y,
                    scale: scale,
                    visible: true
                };
            }

            updateMarkerDebugOverlay(characterName, markerType, matches, visible, hasAnchor = false) {
                const content = document.getElementById('marker-debug-content');
                if (!content) return;

                // Trova o crea item per questo character
                let item = content.querySelector(`[data-character="${characterName}"]`);
                if (!item) {
                    item = document.createElement('div');
                    item.className = 'debug-marker-item';
                    item.dataset.character = characterName;
                    content.appendChild(item);
                }

                // Determina classe CSS per colore
                let statusClass = 'debug-marker-detection';
                let statusIcon = 'üü¢';
                let statusText = 'Detection';

                if (markerType === 'positioning') {
                    statusClass = 'debug-marker-positioning';
                    statusIcon = 'üîµ';
                    statusText = 'Positioning';
                }

                if (hasAnchor) {
                    statusClass = 'debug-marker-anchor';
                    statusIcon = 'üü†';
                    statusText = 'Anchored';
                }

                if (!visible) {
                    statusIcon = 'üî¥';
                }

                // Aggiorna contenuto
                item.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <span style="font-weight: bold;">${characterName}</span>
                            <div style="font-size: 9px; color: #aaa; margin-top: 2px;">
                                ${statusIcon} <span class="${statusClass}">${statusText}</span>
                            </div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-size: 11px; color: ${matches >= 100 ? '#00ff00' : matches >= 40 ? '#ffaa00' : '#ff4444'}">
                                ${matches} matches
                            </div>
                            <div style="font-size: 9px; color: #888;">
                                ${visible ? 'Visible' : 'Hidden'}
                            </div>
                        </div>
                    </div>
                `;

                // Auto-rimuovi vecchi item dopo 5 secondi senza update
                item.dataset.lastUpdate = Date.now();
                setTimeout(() => {
                    const lastUpdate = parseInt(item.dataset.lastUpdate || 0);
                    if (Date.now() - lastUpdate > 5000) {
                        item.remove();
                    }
                }, 5500);
            }

            showError(message) {
                const errorDiv = document.getElementById('error-message');
                errorDiv.textContent = message;
                errorDiv.style.display = 'block';
                setTimeout(() => {
                    errorDiv.style.display = 'none';
                }, 5000);
            }
        }

        // Avvia l'applicazione AR quando la pagina √® caricata
        document.addEventListener('DOMContentLoaded', () => {
            new ARCamera();
        });
    </script>
</body>
</html>
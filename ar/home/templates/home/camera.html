<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Camera</title>
    {% load static %}
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background: #000;
            overflow: hidden;
        }

        #camera-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #camera-stream {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #ar-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .ar-character {
            position: absolute;
            width: 100px;
            height: 100px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            text-align: center;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
            transition: all 0.3s ease;
        }

        .ar-character.active {
            width: 150px;
            height: 150px;
            background: rgba(255, 215, 0, 0.9);
            box-shadow: 0 0 30px rgba(255, 215, 0, 1);
        }

        #controls {
            position: fixed;
            top: 10px;
            left: 10px;
            width: 200px;
            z-index: 20;
            background: rgba(0, 0, 0, 0.2);
            color: white;
            padding: 6px;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            font-size: 10px;
        }

        .info-panel {
            background: rgba(0, 0, 0, 0.3);
            padding: 4px;
            border-radius: 3px;
            margin: 1px 0;
            text-align: left;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .info-title {
            font-size: 9px;
            font-weight: bold;
            margin-right: 4px;
        }

        .info-value {
            font-size: 9px;
            color: #00ff00;
        }

        #character-pointer {
            position: fixed;
            bottom: 80px;
            left: 50%;
            width: 60px;
            height: 60px;
            transform: translate(-50%, 0);
            z-index: 15;
            display: none;
        }

        #pointer-arrow {
            width: 6px;
            height: 60px;
            background: linear-gradient(180deg, #ff0000 0%, #ffff00 50%, #00ff00 100%);
            margin: 0 auto;
            transform-origin: 50% 100%;
            transition: transform 0.3s ease;
            border-radius: 3px 3px 0 0;
            position: relative;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
        }

        #pointer-arrow::before {
            content: '';
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-bottom: 15px solid #ff0000;
            filter: drop-shadow(0 0 5px rgba(255, 0, 0, 0.8));
        }

        #pointer-info {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            text-align: center;
            margin-top: 5px;
        }

        #error-message {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(255, 0, 0, 0.9);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            z-index: 30;
            display: none;
        }

        @media (max-width: 768px) {
            #controls {
                flex-direction: column;
                align-items: stretch;
            }

            .info-panel {
                margin: 2px 0;
            }
        }
    </style>
</head>
<body>
    <div id="camera-container">
        <video id="camera-stream" autoplay playsinline></video>
        <div id="ar-overlay"></div>
    </div>

    <div id="controls">
        <div class="info-panel">
            <div class="info-title">GPS</div>
            <div class="info-value" id="gps-coords">Caricamento...</div>
        </div>

        <div class="info-panel">
            <div class="info-title">Accuracy</div>
            <div class="info-value" id="gps-accuracy">-</div>
        </div>

        <div class="info-panel">
            <div class="info-title">Nearest</div>
            <div class="info-value" id="nearest-distance">-</div>
        </div>

        <div class="info-panel">
            <div class="info-title">Characters</div>
            <div class="info-value" id="character-count">{{ characters.count }}</div>
        </div>
    </div>

    <div id="character-pointer">
        <div id="pointer-arrow"></div>
        <div id="pointer-info">
            <div id="pointer-name">-</div>
            <div id="pointer-distance">-</div>
        </div>
    </div>

    <div id="error-message"></div>

    <script>
        class ARCamera {
            constructor() {
                this.currentPosition = null;
                this.currentHeading = 0;
                this.characters = [];
                this.activeCharacters = [];
                this.nearestCharacter = null;

                this.initCamera();
                this.initGPS();
                this.initOrientation();
                this.loadCharacterData();
            }

            async initCamera() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            facingMode: 'environment',
                            width: { ideal: 1920 },
                            height: { ideal: 1080 }
                        }
                    });
                    document.getElementById('camera-stream').srcObject = stream;
                } catch (error) {
                    this.showError('Errore accesso fotocamera: ' + error.message);
                }
            }

            initGPS() {
                if (!navigator.geolocation) {
                    this.showError('GPS non supportato su questo dispositivo');
                    return;
                }

                const options = {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 60000
                };

                navigator.geolocation.watchPosition(
                    (position) => {
                        this.currentPosition = position;
                        this.updateGPSDisplay();
                        this.updateAROverlay();
                        this.updateCharacterPointer();
                    },
                    (error) => {
                        this.showError('Errore GPS: ' + error.message);
                    },
                    options
                );
            }

            async initOrientation() {
                try {
                    // Richiedi permessi per orientamento dispositivo (iOS 13+)
                    if (typeof DeviceOrientationEvent !== 'undefined' &&
                        typeof DeviceOrientationEvent.requestPermission === 'function') {

                        const permission = await DeviceOrientationEvent.requestPermission();
                        if (permission === 'granted') {
                            this.startOrientationListening();
                        } else {
                            console.log('Permesso orientamento negato');
                        }
                    } else {
                        // Per Android e browser piÃ¹ vecchi
                        this.startOrientationListening();
                    }
                } catch (error) {
                    console.log('Errore richiesta permessi orientamento:', error);
                }
            }

            startOrientationListening() {
                if (window.DeviceOrientationEvent) {
                    window.addEventListener('deviceorientationabsolute', (event) => {
                        if (event.alpha !== null) {
                            this.currentHeading = event.alpha;
                            this.updateCharacterPointer();
                        }
                    });

                    // Fallback
                    window.addEventListener('deviceorientation', (event) => {
                        if (event.alpha !== null && this.currentHeading === 0) {
                            this.currentHeading = event.alpha;
                            this.updateCharacterPointer();
                        }
                    });
                } else {
                    console.log('DeviceOrientation non supportato');
                }
            }

            findNearestCharacter() {
                if (!this.currentPosition || this.characters.length === 0) return null;

                let nearest = null;
                let minDistance = Infinity;

                this.characters.forEach(character => {
                    const distance = this.calculateDistance(
                        this.currentPosition.coords.latitude,
                        this.currentPosition.coords.longitude,
                        character.target_latitude,
                        character.target_longitude
                    );

                    if (distance < minDistance) {
                        minDistance = distance;
                        nearest = { ...character, distance: distance };
                    }
                });

                return nearest;
            }

            async loadCharacterData() {
                try {
                    const response = await fetch('/api/characters/');
                    const data = await response.json();
                    this.characters = data.characters;
                } catch (error) {
                    this.showError('Errore caricamento personaggi: ' + error.message);
                }
            }

            updateGPSDisplay() {
                if (this.currentPosition) {
                    const lat = this.currentPosition.coords.latitude.toFixed(6);
                    const lng = this.currentPosition.coords.longitude.toFixed(6);
                    const accuracy = Math.round(this.currentPosition.coords.accuracy);

                    document.getElementById('gps-coords').textContent = `${lat}, ${lng}`;
                    document.getElementById('gps-accuracy').textContent = `Â±${accuracy}m`;
                }
            }

            updateCharacterPointer() {
                const nearest = this.findNearestCharacter();
                const pointer = document.getElementById('character-pointer');
                const arrow = document.getElementById('pointer-arrow');
                const nameEl = document.getElementById('pointer-name');
                const distanceEl = document.getElementById('pointer-distance');
                const nearestDistanceEl = document.getElementById('nearest-distance');

                if (nearest) {
                    // Aggiorna info nel pannello superiore
                    nearestDistanceEl.textContent = `${Math.round(nearest.distance)}m`;

                    // Calcola la direzione verso il character
                    const bearing = this.calculateBearing(
                        this.currentPosition.coords.latitude,
                        this.currentPosition.coords.longitude,
                        nearest.target_latitude,
                        nearest.target_longitude
                    );

                    // Calcola la direzione relativa considerando l'orientamento del dispositivo
                    const relativeBearing = (bearing - this.currentHeading + 360) % 360;

                    // Mostra il puntatore
                    pointer.style.display = 'block';
                    arrow.style.transform = `rotate(${relativeBearing}deg)`;
                    nameEl.textContent = nearest.name;
                    distanceEl.textContent = `${Math.round(nearest.distance)}m`;
                } else {
                    pointer.style.display = 'none';
                    nearestDistanceEl.textContent = '-';
                }
            }

            updateAROverlay() {
                if (!this.currentPosition || this.characters.length === 0) return;

                const overlay = document.getElementById('ar-overlay');
                overlay.innerHTML = '';

                this.characters.forEach(character => {
                    const distance = this.calculateDistance(
                        this.currentPosition.coords.latitude,
                        this.currentPosition.coords.longitude,
                        character.target_latitude,
                        character.target_longitude
                    );

                    if (distance <= character.activation_distance) {
                        this.createARCharacter(character, distance);
                    }
                });
            }

            createARCharacter(character, distance) {
                const overlay = document.getElementById('ar-overlay');
                const characterDiv = document.createElement('div');
                characterDiv.className = 'ar-character';

                if (distance <= 5) {
                    characterDiv.classList.add('active');
                }

                const bearing = this.calculateBearing(
                    this.currentPosition.coords.latitude,
                    this.currentPosition.coords.longitude,
                    character.target_latitude,
                    character.target_longitude
                );

                const screenPosition = this.worldToScreen(bearing, distance);

                characterDiv.style.left = screenPosition.x + 'px';
                characterDiv.style.top = screenPosition.y + 'px';

                characterDiv.innerHTML = `
                    <div>
                        <strong>${character.name}</strong><br>
                        ${Math.round(distance)}m
                    </div>
                `;

                overlay.appendChild(characterDiv);
            }

            calculateDistance(lat1, lon1, lat2, lon2) {
                const R = 6371e3; // Raggio Terra in metri
                const Ï1 = lat1 * Math.PI/180;
                const Ï2 = lat2 * Math.PI/180;
                const ÎÏ = (lat2-lat1) * Math.PI/180;
                const ÎÎ» = (lon2-lon1) * Math.PI/180;

                const a = Math.sin(ÎÏ/2) * Math.sin(ÎÏ/2) +
                        Math.cos(Ï1) * Math.cos(Ï2) *
                        Math.sin(ÎÎ»/2) * Math.sin(ÎÎ»/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

                return R * c;
            }

            calculateBearing(lat1, lon1, lat2, lon2) {
                const Ï1 = lat1 * Math.PI/180;
                const Ï2 = lat2 * Math.PI/180;
                const ÎÎ» = (lon2-lon1) * Math.PI/180;

                const y = Math.sin(ÎÎ») * Math.cos(Ï2);
                const x = Math.cos(Ï1) * Math.sin(Ï2) -
                        Math.sin(Ï1) * Math.cos(Ï2) * Math.cos(ÎÎ»);

                const Î¸ = Math.atan2(y, x);

                return (Î¸*180/Math.PI + 360) % 360;
            }

            worldToScreen(bearing, distance) {
                const screenWidth = window.innerWidth;
                const screenHeight = window.innerHeight;

                // Converti bearing relativo alla direzione della fotocamera
                const relativeBearing = (bearing - this.currentHeading + 360) % 360;

                // Mappa il bearing su coordinate schermo (FOV di 90 gradi)
                const x = screenWidth * (relativeBearing / 90) % screenWidth;

                // La distanza influenza la posizione verticale
                const y = screenHeight * 0.3 + (distance / 100) * screenHeight * 0.4;

                return { x: Math.max(50, Math.min(x, screenWidth - 50)), y: Math.max(100, Math.min(y, screenHeight - 100)) };
            }

            showError(message) {
                const errorDiv = document.getElementById('error-message');
                errorDiv.textContent = message;
                errorDiv.style.display = 'block';
                setTimeout(() => {
                    errorDiv.style.display = 'none';
                }, 5000);
            }
        }

        // Avvia l'applicazione AR quando la pagina Ã¨ caricata
        document.addEventListener('DOMContentLoaded', () => {
            new ARCamera();
        });

        // Gestisci il cambio di orientamento
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                location.reload();
            }, 500);
        });
    </script>
</body>
</html>
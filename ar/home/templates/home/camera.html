<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>AR Camera</title>
    {% load static %}
    <!-- OpenCV.js for image feature matching -->
    <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background: #000;
            overflow: hidden;
        }

        #camera-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #camera-stream {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #ar-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .ar-character {
            position: absolute;
            width: 100px;
            height: 100px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .ar-character img {
            width: 80px;
            height: 80px;
            object-fit: cover;
        }

        .ar-character.active {
            width: 150px;
            height: 150px;
        }

        .ar-character.active img {
            width: 120px;
            height: 120px;
        }

        .ar-character-info {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            text-align: center;
            margin-top: 5px;
            max-width: 120px;
        }


        #controls {
            position: fixed;
            top: 10px;
            left: 10px;
            width: 200px;
            z-index: 20;
            background: rgba(0, 0, 0, 0.2);
            color: white;
            padding: 6px;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            font-size: 10px;
        }

        .info-panel {
            background: rgba(0, 0, 0, 0.3);
            padding: 4px;
            border-radius: 3px;
            margin: 1px 0;
            text-align: left;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .info-title {
            font-size: 9px;
            font-weight: bold;
            margin-right: 4px;
        }

        .info-value {
            font-size: 9px;
            color: #00ff00;
        }

        #character-pointer {
            position: fixed;
            bottom: 80px;
            left: 50%;
            width: 60px;
            height: 60px;
            transform: translate(-50%, 0);
            z-index: 15;
            display: none;
        }

        #pointer-arrow {
            width: 4px;
            height: 50px;
            background: #00ff00;
            margin: 0 auto;
            transform-origin: 50% 100%;
            transition: transform 0.1s ease-out;
            position: relative;
            border-radius: 2px 2px 0 0;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        #pointer-arrow::before {
            content: '';
            position: absolute;
            top: -12px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 12px solid #00ff00;
        }

        #pointer-info {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            text-align: center;
            margin-top: 5px;
        }

        #error-message {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(255, 0, 0, 0.9);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            z-index: 30;
            display: none;
        }

        @media (max-width: 768px) {
            #controls {
                flex-direction: column;
                align-items: stretch;
            }

            .info-panel {
                margin: 2px 0;
            }
        }
    </style>
</head>
<body>
    <div id="camera-container">
        <video id="camera-stream" autoplay playsinline></video>
        <div id="ar-overlay"></div>
    </div>

    <div id="controls">
        <div class="info-panel">
            <div class="info-title">GPS</div>
            <div class="info-value" id="gps-coords">Caricamento...</div>
        </div>

        <div class="info-panel">
            <div class="info-title">Accuracy</div>
            <div class="info-value" id="gps-accuracy">-</div>
        </div>

        <div class="info-panel">
            <div class="info-title">Altitude</div>
            <div class="info-value" id="gps-altitude">-</div>
        </div>

        <div class="info-panel">
            <div class="info-title">Nearest</div>
            <div class="info-value" id="nearest-distance">-</div>
        </div>

        <div class="info-panel">
            <div class="info-title">Compass</div>
            <div class="info-value" id="compass-status">OFF</div>
        </div>

        <div class="info-panel">
            <div class="info-title">Characters</div>
            <div class="info-value" id="character-count">{{ characters.count }}</div>
        </div>

        <div class="info-panel">
            <div class="info-title">Marker</div>
            <div class="info-value" id="marker-status">-</div>
        </div>
    </div>

    <div id="character-pointer">
        <div id="pointer-arrow"></div>
        <div id="pointer-info">
            <div id="pointer-name">-</div>
            <div id="pointer-distance">-</div>
        </div>
    </div>

    <div id="compass-button" style="position: fixed; bottom: 20px; right: 20px; background: rgba(0,0,0,0.7); color: white; padding: 10px 15px; border-radius: 5px; border: none; font-size: 12px; z-index: 25; cursor: pointer;">
        Enable Compass
    </div>

    <div id="error-message"></div>

    <script>
        // Global flag per OpenCV
        let openCvReady = false;
        function onOpenCvReady() {
            openCvReady = true;
            console.log('OpenCV.js is ready');
        }

        class ARCamera {
            constructor() {
                this.currentPosition = null;
                this.currentHeading = 0;
                this.characters = [];
                this.activeCharacters = [];
                this.nearestCharacter = null;
                this.lastUpdate = 0;
                this.markerDetector = null;
                this.detectedMarkers = new Map(); // marker_id -> position
                this.videoElement = null;

                this.initCamera();
                this.initGPS();
                this.loadCharacterData();
                this.setupCompassButton();
                this.initMarkerDetection();
            }

            async initCamera() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            facingMode: 'environment',
                            width: { ideal: 1920 },
                            height: { ideal: 1080 }
                        }
                    });
                    this.videoElement = document.getElementById('camera-stream');
                    this.videoElement.srcObject = stream;
                } catch (error) {
                    this.showError('Errore accesso fotocamera: ' + error.message);
                }
            }

            async initMarkerDetection() {
                // Aspetta che OpenCV sia pronto
                const waitForOpenCV = setInterval(() => {
                    if (openCvReady) {
                        clearInterval(waitForOpenCV);
                        console.log('Marker detection initialized with OpenCV.js');
                        this.loadMarkerImages();
                        this.startMarkerDetectionLoop();
                    }
                }, 100);

                // Timeout dopo 10 secondi
                setTimeout(() => {
                    clearInterval(waitForOpenCV);
                    if (!openCvReady) {
                        console.log('OpenCV.js failed to load - marker detection disabled');
                    }
                }, 10000);
            }

            async loadMarkerImages() {
                // Carica le immagini marker per i personaggi che le hanno
                this.markerTemplates = new Map();
                let totalFeatures = 0;

                for (const char of this.characters) {
                    if (char.use_marker && char.marker_image) {
                        try {
                            const img = await this.loadImage(char.marker_image);
                            const mat = cv.imread(img);

                            // Estrai features dell'immagine marker
                            const gray = new cv.Mat();
                            cv.cvtColor(mat, gray, cv.COLOR_RGBA2GRAY);

                            const orb = new cv.ORB(500);
                            const keypoints = new cv.KeyPointVector();
                            const descriptors = new cv.Mat();
                            orb.detectAndCompute(gray, new cv.Mat(), keypoints, descriptors);

                            const featureCount = keypoints.size();
                            totalFeatures += featureCount;

                            this.markerTemplates.set(char.id, {
                                character: char,
                                keypoints: keypoints,
                                descriptors: descriptors,
                                width: mat.cols,
                                height: mat.rows,
                                featureCount: featureCount
                            });

                            mat.delete();
                            gray.delete();
                            console.log(`Loaded marker for ${char.name}: ${featureCount} features extracted`);
                        } catch (error) {
                            console.log(`Failed to load marker for ${char.name}:`, error);
                        }
                    }
                }

                // Aggiorna UI con info sui marker caricati
                const markerStatus = document.getElementById('marker-status');
                if (this.markerTemplates.size > 0) {
                    markerStatus.textContent = `${this.markerTemplates.size} loaded (${totalFeatures} features)`;
                    markerStatus.style.color = '#00ff00';
                } else {
                    markerStatus.textContent = 'None';
                    markerStatus.style.color = '#ff9900';
                }
            }

            loadImage(url) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => resolve(img);
                    img.onerror = reject;
                    img.src = url;
                });
            }

            startMarkerDetectionLoop() {
                // Canvas nascosto per processing
                this.processingCanvas = document.createElement('canvas');
                this.processingCtx = this.processingCanvas.getContext('2d');

                // Esegui detection ogni 500ms
                setInterval(() => {
                    if (openCvReady && this.videoElement && this.videoElement.readyState === 4 && this.markerTemplates.size > 0) {
                        this.detectMarkersInFrame();
                    }
                }, 500);
            }

            detectMarkersInFrame() {
                try {
                    // Cattura frame dal video
                    this.processingCanvas.width = this.videoElement.videoWidth;
                    this.processingCanvas.height = this.videoElement.videoHeight;
                    this.processingCtx.drawImage(this.videoElement, 0, 0);

                    const src = cv.imread(this.processingCanvas);
                    const gray = new cv.Mat();
                    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

                    // Estrai features dal frame corrente
                    const orb = new cv.ORB(500);
                    const keypoints = new cv.KeyPointVector();
                    const descriptors = new cv.Mat();
                    orb.detectAndCompute(gray, new cv.Mat(), keypoints, descriptors);

                    this.detectedMarkers.clear();

                    // Confronta con ogni marker template
                    let bestMatch = null;
                    let maxMatches = 0;

                    for (const [charId, template] of this.markerTemplates) {
                        const matches = this.matchFeatures(descriptors, template.descriptors);

                        if (matches.length > maxMatches) {
                            maxMatches = matches.length;
                            bestMatch = { charId, template, matches };
                        }

                        // Soglia match: richiede un numero significativo per evitare falsi positivi
                        const minMatches = Math.max(40, template.featureCount * 0.10); // Min 40 o 10% delle features
                        if (matches.length >= minMatches) {
                            // Calcola posizione media dei match
                            let centerX = 0, centerY = 0;
                            matches.forEach(m => {
                                const kp = keypoints.get(m.queryIdx);
                                centerX += kp.pt.x;
                                centerY += kp.pt.y;
                            });
                            centerX /= matches.length;
                            centerY /= matches.length;

                            // Stima dimensione basata sui keypoint
                            const avgScale = this.videoElement.videoWidth / template.width;

                            this.detectedMarkers.set(charId, {
                                character: template.character,
                                screenX: centerX,
                                screenY: centerY,
                                matches: matches.length,
                                confidence: Math.min(1.0, matches.length / 50),
                                bbox: [centerX - 50, centerY - 50, 100, 100] // Stima approssimativa
                            });

                            console.log(`Marker detected for ${template.character.name}: ${matches.length} matches`);
                        }
                    }

                    // Aggiorna UI con status detection
                    const markerStatus = document.getElementById('marker-status');
                    if (this.detectedMarkers.size > 0) {
                        const detected = Array.from(this.detectedMarkers.values())[0];
                        markerStatus.textContent = `🟢 ${detected.matches} matches`;
                        markerStatus.style.color = '#00ff00';
                    } else if (bestMatch && maxMatches > 0) {
                        const template = bestMatch.template;
                        const minNeeded = Math.max(40, template.featureCount * 0.10);
                        markerStatus.textContent = `🟡 ${maxMatches}/${Math.round(minNeeded)} matches`;
                        markerStatus.style.color = '#ff9900';
                    } else {
                        markerStatus.textContent = `🔴 No matches`;
                        markerStatus.style.color = '#ff0000';
                    }

                    // Cleanup
                    src.delete();
                    gray.delete();
                    keypoints.delete();
                    descriptors.delete();

                    // Aggiorna overlay se ci sono marker rilevati
                    if (this.detectedMarkers.size > 0) {
                        this.updateAROverlay();
                    }
                } catch (error) {
                    console.log('Detection error:', error);
                }
            }

            matchFeatures(desc1, desc2) {
                if (!desc1 || !desc2 || desc1.rows === 0 || desc2.rows === 0) {
                    return [];
                }

                const bf = new cv.BFMatcher(cv.NORM_HAMMING, true);
                const matches = new cv.DMatchVector();
                bf.match(desc1, desc2, matches);

                // Filtra i match migliori (soglia più permissiva per scene ampie)
                const goodMatches = [];
                for (let i = 0; i < matches.size(); i++) {
                    const match = matches.get(i);
                    if (match.distance < 70) { // Threshold più permissivo per variazioni di luce/angolazione
                        goodMatches.push(match);
                    }
                }

                matches.delete();
                return goodMatches;
            }

            initGPS() {
                if (!navigator.geolocation) {
                    this.showError('GPS non supportato su questo dispositivo');
                    return;
                }

                const options = {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 60000
                };

                navigator.geolocation.watchPosition(
                    (position) => {
                        this.currentPosition = position;
                        this.updateGPSDisplay();
                        this.updateAROverlay();
                        this.updateCharacterPointer();
                    },
                    (error) => {
                        this.showError('Errore GPS: ' + error.message);
                    },
                    options
                );
            }

            setupCompassButton() {
                const button = document.getElementById('compass-button');
                button.addEventListener('click', async () => {
                    button.textContent = 'Activating...';
                    await this.initOrientation();
                });
            }

            async initOrientation() {
                try {
                    const status = document.getElementById('compass-status');

                    // Richiedi permessi per orientamento dispositivo (iOS 13+)
                    if (typeof DeviceOrientationEvent !== 'undefined' &&
                        typeof DeviceOrientationEvent.requestPermission === 'function') {

                        const permission = await DeviceOrientationEvent.requestPermission();

                        if (permission === 'granted') {
                            this.startOrientationListening();
                            status.textContent = 'ON';
                            document.getElementById('compass-button').style.display = 'none';
                        } else {
                            status.textContent = 'DENIED';
                        }
                    } else {
                        // Per Android e browser più vecchi
                        this.startOrientationListening();
                        status.textContent = 'ON';
                        document.getElementById('compass-button').style.display = 'none';
                    }
                } catch (error) {
                    console.log('Errore richiesta permessi orientamento:', error);
                    document.getElementById('compass-status').textContent = 'ERROR';
                }
            }

            startOrientationListening() {
                if (window.DeviceOrientationEvent) {
                    // Usa deviceorientationabsolute per il nord magnetico assoluto (iOS/Android moderni)
                    window.addEventListener('deviceorientationabsolute', (event) => {
                        if (event.alpha !== null) {
                            // Per iOS, event.alpha è relativo al nord magnetico
                            // Per Android con supporto assoluto, è già corretto
                            this.currentHeading = event.alpha;
                            document.getElementById('compass-status').textContent = `${Math.round(event.alpha)}°`;
                            this.throttledUpdatePointer();
                        }
                    });

                    // Fallback per dispositivi senza supporto assoluto
                    window.addEventListener('deviceorientation', (event) => {
                        if (event.alpha !== null) {
                            // Su alcuni dispositivi potrebbe essere necessario correggere l'orientamento
                            let heading = event.alpha;

                            // Correzione per iOS dove l'orientamento potrebbe essere diverso
                            if (event.webkitCompassHeading) {
                                heading = event.webkitCompassHeading;
                            }

                            this.currentHeading = heading;
                            document.getElementById('compass-status').textContent = `${Math.round(heading)}°`;
                            this.throttledUpdatePointer();
                        }
                    });
                } else {
                    document.getElementById('compass-status').textContent = 'NOT_SUPPORTED';
                }
            }

            throttledUpdatePointer() {
                const now = Date.now();
                if (now - this.lastUpdate > 50) { // Aggiorna max ogni 50ms
                    this.lastUpdate = now;
                    this.updateCharacterPointer();
                }
            }

            findNearestCharacter() {
                if (!this.currentPosition || this.characters.length === 0) return null;

                let nearest = null;
                let minDistance = Infinity;

                this.characters.forEach(character => {
                    const distance = this.calculateDistance(
                        this.currentPosition.coords.latitude,
                        this.currentPosition.coords.longitude,
                        character.target_latitude,
                        character.target_longitude
                    );

                    if (distance < minDistance) {
                        minDistance = distance;
                        nearest = { ...character, distance: distance };
                    }
                });

                return nearest;
            }

            async loadCharacterData() {
                try {
                    const response = await fetch('/api/characters/');
                    const data = await response.json();
                    this.characters = data.characters;
                    console.log('Characters loaded:', JSON.stringify(this.characters, null, 2));
                } catch (error) {
                    this.showError('Errore caricamento personaggi: ' + error.message);
                }
            }

            updateGPSDisplay() {
                if (this.currentPosition) {
                    const lat = this.currentPosition.coords.latitude.toFixed(6);
                    const lng = this.currentPosition.coords.longitude.toFixed(6);
                    const accuracy = Math.round(this.currentPosition.coords.accuracy);
                    const altitude = this.currentPosition.coords.altitude;

                    document.getElementById('gps-coords').textContent = `${lat}, ${lng}`;
                    document.getElementById('gps-accuracy').textContent = `±${accuracy}m`;

                    if (altitude !== null) {
                        document.getElementById('gps-altitude').textContent = `${Math.round(altitude)}m`;
                    } else {
                        document.getElementById('gps-altitude').textContent = 'N/A';
                    }
                }
            }

            updateCharacterPointer() {
                const nearest = this.findNearestCharacter();
                const pointer = document.getElementById('character-pointer');
                const arrow = document.getElementById('pointer-arrow');
                const nameEl = document.getElementById('pointer-name');
                const distanceEl = document.getElementById('pointer-distance');
                const nearestDistanceEl = document.getElementById('nearest-distance');

                if (nearest && this.currentPosition) {
                    // Aggiorna info nel pannello superiore
                    nearestDistanceEl.textContent = `${Math.round(nearest.distance)}m`;

                    // Calcola la direzione verso il character più vicino
                    const bearing = this.calculateBearing(
                        this.currentPosition.coords.latitude,
                        this.currentPosition.coords.longitude,
                        nearest.target_latitude,
                        nearest.target_longitude
                    );

                    // Calcola la direzione relativa considerando l'orientamento del dispositivo
                    // La freccia punta nella direzione corretta relativa all'orientamento
                    const relativeBearing = (bearing - this.currentHeading + 360) % 360;

                    // Mostra il puntatore e aggiorna la direzione della freccia
                    pointer.style.display = 'block';
                    arrow.style.transform = `rotate(${relativeBearing}deg)`;
                    nameEl.textContent = nearest.name;
                    distanceEl.textContent = `${Math.round(nearest.distance)}m`;

                    // Aggiorna il character più vicino
                    this.nearestCharacter = nearest;
                } else {
                    pointer.style.display = 'none';
                    nearestDistanceEl.textContent = '-';
                    this.nearestCharacter = null;
                }
            }

            updateAROverlay() {
                if (!this.currentPosition || this.characters.length === 0) return;

                const overlay = document.getElementById('ar-overlay');
                overlay.innerHTML = '';

                this.characters.forEach(character => {
                    const distance = this.calculateDistance(
                        this.currentPosition.coords.latitude,
                        this.currentPosition.coords.longitude,
                        character.target_latitude,
                        character.target_longitude
                    );

                    if (distance <= character.activation_distance) {
                        this.createARCharacter(character, distance);
                    }
                });
            }

            createARCharacter(character, distance) {
                const overlay = document.getElementById('ar-overlay');
                let screenPosition;
                let scale;

                // MODALITÀ MARKER: Se il personaggio usa marker e il marker è rilevato
                if (character.use_marker && this.detectedMarkers.has(character.id)) {
                    const marker = this.detectedMarkers.get(character.id);

                    // Calcola posizione relativa al marker rilevato
                    const markerX = marker.screenX;
                    const markerY = marker.screenY;
                    const markerWidth = marker.bbox[2];

                    // Converti coordinate video in coordinate schermo
                    const scaleX = window.innerWidth / this.videoElement.videoWidth;
                    const scaleY = window.innerHeight / this.videoElement.videoHeight;

                    // Applica offset dal marker
                    const pixelsPerMeter = markerWidth * scaleX / 0.3; // Assumo oggetto di ~30cm
                    screenPosition = {
                        x: (markerX * scaleX) + (character.marker_offset_x * pixelsPerMeter),
                        y: (markerY * scaleY) + (character.marker_offset_y * pixelsPerMeter),
                        visible: true
                    };

                    // Scala basata sulla dimensione del marker e distanza stimata
                    const estimatedDistance = 1.0 / (markerWidth / this.videoElement.videoWidth);
                    scale = (character.base_size || 1.0) * Math.max(0.5, Math.min(2, 1 / estimatedDistance));

                    console.log(`Character ${character.name}: MARKER MODE - matches=${marker.matches}, confidence=${marker.confidence.toFixed(2)}`);
                } else if (character.use_marker) {
                    // Marker abilitato ma non rilevato - non mostrare
                    return;
                } else {
                    // MODALITÀ GPS: Usa bearing e distanza normale
                    const bearing = this.calculateBearing(
                        this.currentPosition.coords.latitude,
                        this.currentPosition.coords.longitude,
                        character.target_latitude,
                        character.target_longitude
                    );

                    screenPosition = this.worldToScreen(bearing, distance, character);

                    // Se il personaggio è fuori dal campo visivo, non mostrarlo
                    if (!screenPosition || !screenPosition.visible) {
                        return;
                    }

                    scale = screenPosition.scale;
                }

                const characterDiv = document.createElement('div');
                characterDiv.className = 'ar-character';

                // Applica la scala
                const baseSize = 80;
                const imgSize = baseSize * scale;

                // Posiziona il personaggio con trasformazione per centrarlo
                characterDiv.style.left = screenPosition.x + 'px';
                characterDiv.style.top = screenPosition.y + 'px';
                characterDiv.style.transform = 'translate(-50%, -50%)';

                // Mostra l'immagine del personaggio con dimensione scalata
                console.log(`Character ${character.name}: distance=${Math.round(distance)}m, scale=${scale.toFixed(2)}, mode=${character.display_mode}`);
                if (character.character_image) {
                    characterDiv.innerHTML = `
                        <img src="${character.character_image}"
                             alt="${character.name}"
                             style="width: ${imgSize}px; height: ${imgSize}px;">
                        <div class="ar-character-info">
                            <div><strong>${character.name}</strong></div>
                            <div>${Math.round(distance)}m</div>
                        </div>
                    `;
                    overlay.appendChild(characterDiv);
                } else {
                    console.log(`Character ${character.name} has no image!`);
                }
            }

            calculateDistance(lat1, lon1, lat2, lon2) {
                const R = 6371e3; // Raggio Terra in metri
                const φ1 = lat1 * Math.PI/180;
                const φ2 = lat2 * Math.PI/180;
                const Δφ = (lat2-lat1) * Math.PI/180;
                const Δλ = (lon2-lon1) * Math.PI/180;

                const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                        Math.cos(φ1) * Math.cos(φ2) *
                        Math.sin(Δλ/2) * Math.sin(Δλ/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

                return R * c;
            }

            calculateBearing(lat1, lon1, lat2, lon2) {
                const φ1 = lat1 * Math.PI/180;
                const φ2 = lat2 * Math.PI/180;
                const Δλ = (lon2-lon1) * Math.PI/180;

                const y = Math.sin(Δλ) * Math.cos(φ2);
                const x = Math.cos(φ1) * Math.sin(φ2) -
                        Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);

                const θ = Math.atan2(y, x);

                return (θ*180/Math.PI + 360) % 360;
            }

            worldToScreen(bearing, distance, character) {
                const screenWidth = window.innerWidth;
                const screenHeight = window.innerHeight;

                // Campo visivo della fotocamera (tipicamente 60-80 gradi per smartphone)
                const FOV = 70;

                // Calcola il bearing relativo alla direzione della fotocamera
                let relativeBearing = (bearing - this.currentHeading + 360) % 360;

                // Normalizza il bearing tra -180 e 180 gradi
                if (relativeBearing > 180) {
                    relativeBearing -= 360;
                }

                // Controlla se il personaggio è nel campo visivo
                if (Math.abs(relativeBearing) > FOV / 2) {
                    // Fuori dal campo visivo - non mostrare
                    return null;
                }

                // Mappa il bearing su coordinate schermo
                // 0 gradi (davanti) = centro schermo
                // -FOV/2 = sinistra, +FOV/2 = destra
                const x = screenWidth / 2 + (relativeBearing / FOV) * screenWidth;

                // Calcola posizione verticale considerando altitudine e height_offset
                let y = screenHeight * 0.5; // Centro verticale di default

                // Se abbiamo dati di altitudine GPS
                if (this.currentPosition.coords.altitude !== null && character.altitude !== 0) {
                    const altitudeDiff = character.altitude - this.currentPosition.coords.altitude + character.height_offset;
                    // Converti differenza altitudine in offset verticale (negativo = più in alto)
                    const altitudeOffset = -altitudeDiff * 2; // Pixel per metro
                    y = screenHeight * 0.5 + altitudeOffset;
                } else {
                    // Fallback: usa distanza per calcolare posizione verticale
                    // Più vicino = più in basso (effetto prospettico)
                    const verticalOffset = Math.max(0, Math.min(1, distance / 100));

                    // Applica height_offset
                    const heightAdjustment = character.height_offset * -3; // Pixel per metro

                    if (character.display_mode === 'floating') {
                        y = screenHeight * (0.3 + verticalOffset * 0.1) + heightAdjustment;
                    } else if (character.display_mode === 'wall') {
                        y = screenHeight * 0.4 + heightAdjustment;
                    } else { // standing
                        y = screenHeight * (0.5 + verticalOffset * 0.15) + heightAdjustment;
                    }
                }

                // Calcola la scala in base alla distanza e base_size
                const baseScale = Math.max(0.3, Math.min(2, 50 / distance));
                const scale = baseScale * (character.base_size || 1.0);

                return {
                    x: x,
                    y: y,
                    scale: scale,
                    visible: true
                };
            }

            showError(message) {
                const errorDiv = document.getElementById('error-message');
                errorDiv.textContent = message;
                errorDiv.style.display = 'block';
                setTimeout(() => {
                    errorDiv.style.display = 'none';
                }, 5000);
            }
        }

        // Avvia l'applicazione AR quando la pagina è caricata
        document.addEventListener('DOMContentLoaded', () => {
            new ARCamera();
        });

        // Gestisci il cambio di orientamento
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                location.reload();
            }, 500);
        });
    </script>
</body>
</html>
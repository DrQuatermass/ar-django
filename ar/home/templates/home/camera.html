<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>AR Camera</title>
    {% load static %}
    <!-- OpenCV.js for image feature matching -->
    <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background: #000;
            overflow: hidden;
        }

        #camera-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #camera-stream {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #ar-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .ar-character {
            position: absolute;
            width: 100px;
            height: 100px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            /* Transizioni smooth per posizione, dimensione e opacit√† */
            transition: left 0.2s ease-out, top 0.2s ease-out, transform 0.2s ease-out, opacity 0.3s ease-in-out, width 0.3s ease, height 0.3s ease;
            will-change: transform, opacity;
        }

        .ar-character img {
            width: 80px;
            height: 80px;
            object-fit: cover;
            /* Transizione smooth per dimensione immagine */
            transition: width 0.3s ease, height 0.3s ease;
        }

        .ar-character.active {
            width: 150px;
            height: 150px;
        }

        .ar-character.active img {
            width: 120px;
            height: 120px;
        }

        .ar-character-info {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            text-align: center;
            margin-top: 5px;
            max-width: 120px;
        }


        #controls {
            position: fixed;
            top: 10px;
            left: 10px;
            width: 200px;
            z-index: 20;
            background: rgba(0, 0, 0, 0.2);
            color: white;
            padding: 6px;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            font-size: 10px;
        }

        .info-panel {
            background: rgba(0, 0, 0, 0.3);
            padding: 4px;
            border-radius: 3px;
            margin: 1px 0;
            text-align: left;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .info-title {
            font-size: 9px;
            font-weight: bold;
            margin-right: 4px;
        }

        .info-value {
            font-size: 9px;
            color: #00ff00;
        }

        #character-pointer {
            position: fixed;
            bottom: 80px;
            left: 50%;
            width: 60px;
            height: 60px;
            transform: translate(-50%, 0);
            z-index: 15;
            display: none;
        }

        #pointer-arrow {
            width: 4px;
            height: 50px;
            background: #00ff00;
            margin: 0 auto;
            transform-origin: 50% 100%;
            transition: transform 0.1s ease-out;
            position: relative;
            border-radius: 2px 2px 0 0;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        #pointer-arrow::before {
            content: '';
            position: absolute;
            top: -12px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 12px solid #00ff00;
        }

        #pointer-info {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            text-align: center;
            margin-top: 5px;
        }

        #error-message {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(255, 0, 0, 0.9);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            z-index: 30;
            display: none;
        }

        #debug-log {
            position: fixed;
            bottom: 60px;
            left: 10px;
            right: 10px;
            max-height: 150px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ff00;
            padding: 10px;
            border-radius: 5px;
            font-size: 9px;
            font-family: monospace;
            overflow-y: auto;
            z-index: 25;
            display: none;
        }

        #debug-log.visible {
            display: block;
        }

        #toggle-debug {
            position: fixed;
            bottom: 20px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 10px;
            z-index: 26;
            cursor: pointer;
            border: 1px solid #00ff00;
        }

        .marker-highlight {
            position: absolute;
            border: 3px solid #00ff00;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
            pointer-events: none;
            z-index: 15;
        }

        @media (max-width: 768px) {
            #controls {
                flex-direction: column;
                align-items: stretch;
            }

            .info-panel {
                margin: 2px 0;
            }
        }
    </style>
</head>
<body>
    <div id="camera-container">
        <video id="camera-stream" autoplay playsinline></video>
        <div id="ar-overlay"></div>
    </div>

    <div id="controls">
        <div class="info-panel">
            <div class="info-title">GPS</div>
            <div class="info-value" id="gps-coords">Caricamento...</div>
        </div>

        <div class="info-panel">
            <div class="info-title">Accuracy</div>
            <div class="info-value" id="gps-accuracy">-</div>
        </div>

        <div class="info-panel">
            <div class="info-title">Altitude</div>
            <div class="info-value" id="gps-altitude">-</div>
        </div>

        <div class="info-panel">
            <div class="info-title">Nearest</div>
            <div class="info-value" id="nearest-distance">-</div>
        </div>

        <div class="info-panel">
            <div class="info-title">Compass</div>
            <div class="info-value" id="compass-status">OFF</div>
        </div>

        <div class="info-panel">
            <div class="info-title">Characters</div>
            <div class="info-value" id="character-count">{{ characters.count }}</div>
        </div>

        <div class="info-panel">
            <div class="info-title">Marker</div>
            <div class="info-value" id="marker-status">-</div>
        </div>
    </div>

    <div id="character-pointer">
        <div id="pointer-arrow"></div>
        <div id="pointer-info">
            <div id="pointer-name">-</div>
            <div id="pointer-distance">-</div>
        </div>
    </div>

    <div id="compass-button" style="position: fixed; bottom: 20px; right: 20px; background: rgba(0,0,0,0.7); color: white; padding: 10px 15px; border-radius: 5px; border: none; font-size: 12px; z-index: 25; cursor: pointer;">
        Enable Compass
    </div>

    <div id="error-message"></div>
    <button id="toggle-debug" onclick="toggleDebugLog()">üêõ Debug</button>
    <div id="debug-log"></div>

    <script>
        function toggleDebugLog() {
            const log = document.getElementById('debug-log');
            log.classList.toggle('visible');
        }
    </script>

    <script>
        // Debug logger che mostra i log sullo schermo
        const debugLog = [];
        const originalConsoleLog = console.log;
        const originalConsoleError = console.error;

        function updateDebugDisplay() {
            const debugDiv = document.getElementById('debug-log');
            if (debugDiv) {
                debugDiv.innerHTML = debugLog.slice(-10).join('<br>');
                debugDiv.scrollTop = debugDiv.scrollHeight;
            }
        }

        console.log = function(...args) {
            originalConsoleLog.apply(console, args);
            debugLog.push(`[LOG] ${args.join(' ')}`);
            updateDebugDisplay();
        };

        console.error = function(...args) {
            originalConsoleError.apply(console, args);
            debugLog.push(`[ERR] ${args.join(' ')}`);
            updateDebugDisplay();
        };
    </script>

    <script>
        // EMBEDDED CHARACTER DATA (pre-loaded dal server - zero latency)
        window.EMBEDDED_CHARACTERS = {{ characters_json|safe }};
        console.log('‚úÖ Embedded character data loaded:', window.EMBEDDED_CHARACTERS.length, 'characters');
    </script>

    <script>
        // Global flag per OpenCV
        let openCvReady = false;
        function onOpenCvReady() {
            openCvReady = true;
            console.log('‚úÖ OpenCV.js loaded successfully');
            const markerStatus = document.getElementById('marker-status');
            if (markerStatus) {
                markerStatus.textContent = 'Loading...';
                markerStatus.style.color = '#00ff00';
            }
        }

        // Inizializza status
        window.addEventListener('DOMContentLoaded', () => {
            const markerStatus = document.getElementById('marker-status');
            if (markerStatus) {
                markerStatus.textContent = 'Loading OpenCV...';
                markerStatus.style.color = '#ffff00';
            }
        });

        class ARCamera {
            constructor() {
                this.currentPosition = null;
                this.currentHeading = 0;
                this.characters = [];
                this.activeCharacters = [];
                this.nearestCharacter = null;
                this.lastUpdate = 0;
                this.markerDetector = null;
                this.detectedMarkers = new Map(); // marker_id -> position
                this.videoElement = null;

                // Stabilizzazione e smoothing
                this.characterStates = new Map(); // charId -> { visible, lastSeen, position, positionHistory }
                this.PERSISTENCE_FRAMES = 5; // Mantieni visibile per N frames dopo perdita marker
                this.POSITION_HISTORY_SIZE = 2; // Media mobile su N posizioni (ridotto per reattivit√†)
                this.HYSTERESIS_SHOW = 100; // Soglia per mostrare
                this.HYSTERESIS_HIDE = 50; // Soglia per nascondere
                this.OUTLIER_THRESHOLD = 1.2; // Soglia outlier: 120% distanza media (pi√π aggressivo)

                this.initCamera();
                this.initGPS();
                this.loadCharacterData();
                this.setupCompassButton();
                this.initMarkerDetection();
            }

            async initCamera() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            facingMode: 'environment',
                            width: { ideal: 1920 },
                            height: { ideal: 1080 }
                        }
                    });
                    this.videoElement = document.getElementById('camera-stream');
                    this.videoElement.srcObject = stream;
                } catch (error) {
                    this.showError('Errore accesso fotocamera: ' + error.message);
                }
            }

            async initMarkerDetection() {
                console.log('Initializing marker detection...');

                // Aspetta che OpenCV sia pronto
                const waitForOpenCV = setInterval(() => {
                    if (openCvReady) {
                        clearInterval(waitForOpenCV);
                        console.log('‚úÖ OpenCV.js ready - initializing marker detection');
                        this.loadMarkerImages();
                        this.startMarkerDetectionLoop();
                    }
                }, 100);

                // Timeout dopo 30 secondi (OpenCV √® pesante su mobile)
                setTimeout(() => {
                    clearInterval(waitForOpenCV);
                    if (!openCvReady) {
                        console.error('‚ùå OpenCV.js failed to load after 30s - marker detection disabled');
                        console.error('Possible causes: slow connection, mobile browser compatibility, CORS issue');
                        const markerStatus = document.getElementById('marker-status');
                        markerStatus.textContent = 'OpenCV timeout (GPS only)';
                        markerStatus.style.color = '#ff9900';
                        // Continua con solo GPS
                    }
                }, 30000);
            }

            async loadMarkerImages() {
                console.log(`Loading marker images for ${this.characters.length} characters...`);

                // Aspetta che OpenCV sia completamente pronto
                await new Promise(resolve => setTimeout(resolve, 500));

                // Carica i detection markers e positioning markers
                this.markerTemplates = new Map();
                this.positioningMarkerTemplates = new Map();
                let totalFeatures = 0;

                for (const char of this.characters) {
                    console.log(`Checking character: ${char.name}, use_marker: ${char.use_marker}, marker_image: ${char.marker_image}`);
                    if (char.use_marker && char.marker_image) {
                        try {
                            // DETECTION MARKER - decide SE mostrare il character
                            const img = await this.loadImage(char.marker_image);

                            // Doppio controllo che cv sia pronto
                            if (!cv || !cv.imread) {
                                throw new Error('OpenCV imread not ready');
                            }

                            const mat = cv.imread(img);
                            const gray = new cv.Mat();
                            cv.cvtColor(mat, gray, cv.COLOR_RGBA2GRAY);

                            // Estrai features (500 funziona meglio su iOS)
                            const orb = new cv.ORB(500);
                            const keypoints = new cv.KeyPointVector();
                            const descriptors = new cv.Mat();
                            orb.detectAndCompute(gray, new cv.Mat(), keypoints, descriptors);

                            const featureCount = keypoints.size();
                            totalFeatures += featureCount;

                            this.markerTemplates.set(char.id, {
                                character: char,
                                keypoints: keypoints,
                                descriptors: descriptors,
                                width: mat.cols,
                                height: mat.rows,
                                featureCount: featureCount,
                                type: 'detection'
                            });

                            mat.delete();
                            gray.delete();
                            console.log(`Loaded detection marker for ${char.name}: ${featureCount} features`);

                            // POSITIONING MARKER - decide DOVE posizionare il character (opzionale)
                            if (char.positioning_marker_image) {
                                const posImg = await this.loadImage(char.positioning_marker_image);
                                const posMat = cv.imread(posImg);
                                const posGray = new cv.Mat();
                                cv.cvtColor(posMat, posGray, cv.COLOR_RGBA2GRAY);

                                const posOrb = new cv.ORB(500);
                                const posKeypoints = new cv.KeyPointVector();
                                const posDescriptors = new cv.Mat();
                                posOrb.detectAndCompute(posGray, new cv.Mat(), posKeypoints, posDescriptors);

                                const posFeatureCount = posKeypoints.size();

                                this.positioningMarkerTemplates.set(char.id, {
                                    character: char,
                                    keypoints: posKeypoints,
                                    descriptors: posDescriptors,
                                    width: posMat.cols,
                                    height: posMat.rows,
                                    featureCount: posFeatureCount,
                                    type: 'positioning'
                                });

                                posMat.delete();
                                posGray.delete();
                                console.log(`Loaded positioning marker for ${char.name}: ${posFeatureCount} features`);
                            }
                        } catch (error) {
                            console.log(`Failed to load marker for ${char.name}:`, error);
                        }
                    }
                }

                // Aggiorna UI con info sui marker caricati
                const markerStatus = document.getElementById('marker-status');
                if (this.markerTemplates.size > 0) {
                    markerStatus.textContent = `${this.markerTemplates.size}D/${this.positioningMarkerTemplates.size}P loaded`;
                    markerStatus.style.color = '#00ff00';
                } else {
                    markerStatus.textContent = 'None';
                    markerStatus.style.color = '#ff9900';
                }
            }

            loadImage(url) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => resolve(img);
                    img.onerror = reject;
                    img.src = url;
                });
            }

            startMarkerDetectionLoop() {
                // Canvas nascosto per processing
                this.processingCanvas = document.createElement('canvas');
                this.processingCtx = this.processingCanvas.getContext('2d');

                // Esegui detection ogni 500ms
                setInterval(() => {
                    if (openCvReady && this.videoElement && this.videoElement.readyState === 4 && this.markerTemplates.size > 0) {
                        this.detectMarkersInFrame();
                    }
                }, 500);
            }

            detectMarkersInFrame() {
                try {
                    // Cattura frame dal video
                    this.processingCanvas.width = this.videoElement.videoWidth;
                    this.processingCanvas.height = this.videoElement.videoHeight;
                    this.processingCtx.drawImage(this.videoElement, 0, 0);

                    const src = cv.imread(this.processingCanvas);
                    const gray = new cv.Mat();
                    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

                    // Estrai features dal frame corrente
                    const orb = new cv.ORB(500);
                    const keypoints = new cv.KeyPointVector();
                    const descriptors = new cv.Mat();
                    orb.detectAndCompute(gray, new cv.Mat(), keypoints, descriptors);

                    this.detectedMarkers.clear();
                    this.detectedPositioningMarkers = this.detectedPositioningMarkers || new Map();
                    this.detectedPositioningMarkers.clear();

                    // Cerca marker solo per character nell'area GPS
                    let bestMatch = null;
                    let maxMatches = 0;

                    if (!this.currentPosition) {
                        console.log('No GPS position available for marker detection');
                        src.delete();
                        gray.delete();
                        keypoints.delete();
                        descriptors.delete();
                        return;
                    }

                    for (const [charId, template] of this.markerTemplates) {
                        const character = template.character;

                        // Calcola distanza dal character
                        const distance = this.calculateDistance(
                            this.currentPosition.coords.latitude,
                            this.currentPosition.coords.longitude,
                            character.target_latitude,
                            character.target_longitude
                        );

                        // OTTIMIZZAZIONE: Rileva marker solo se dentro l'area di attivazione
                        if (distance > character.activation_distance) {
                            console.log(`Skipping marker detection for ${character.name}: too far (${Math.round(distance)}m > ${character.activation_distance}m)`);
                            continue;
                        }

                        console.log(`Detecting marker for ${character.name}: inside area (${Math.round(distance)}m)`);

                        const matches = this.matchFeatures(descriptors, template.descriptors);

                        if (matches.length > maxMatches) {
                            maxMatches = matches.length;
                            bestMatch = { charId, template, matches, keypoints };
                        }

                        // DETECTION MARKER: Salva sempre i dati per visualizzare keypoints
                        if (matches.length > 0) {
                            // FILTRO OUTLIERS anche per detection marker
                            // Prima passata: calcola centro grezzo
                            let tempCenterX = 0, tempCenterY = 0;
                            const allDetectionKeypoints = [];

                            matches.forEach(m => {
                                const kp = keypoints.get(m.queryIdx);
                                tempCenterX += kp.pt.x;
                                tempCenterY += kp.pt.y;
                                allDetectionKeypoints.push({ x: kp.pt.x, y: kp.pt.y });
                            });

                            tempCenterX /= matches.length;
                            tempCenterY /= matches.length;

                            // Calcola distanze e filtra outliers
                            const detectionDistances = allDetectionKeypoints.map(kp => {
                                const dx = kp.x - tempCenterX;
                                const dy = kp.y - tempCenterY;
                                return Math.sqrt(dx * dx + dy * dy);
                            });

                            const avgDetectionDistance = detectionDistances.reduce((sum, d) => sum + d, 0) / detectionDistances.length;
                            const maxAllowedDetectionDistance = avgDetectionDistance * this.OUTLIER_THRESHOLD;

                            // Seconda passata: usa solo keypoints filtrati
                            const matchedKeypoints = [];
                            let centerX = 0, centerY = 0;
                            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                            let filteredDetectionCount = 0;

                            allDetectionKeypoints.forEach((kp, idx) => {
                                if (detectionDistances[idx] <= maxAllowedDetectionDistance) {
                                    centerX += kp.x;
                                    centerY += kp.y;
                                    minX = Math.min(minX, kp.x);
                                    minY = Math.min(minY, kp.y);
                                    maxX = Math.max(maxX, kp.x);
                                    maxY = Math.max(maxY, kp.y);
                                    matchedKeypoints.push({ x: kp.x, y: kp.y, type: 'detection' });
                                    filteredDetectionCount++;
                                }
                            });

                            // Fallback se troppi filtrati
                            if (filteredDetectionCount < matches.length * 0.3) {
                                centerX = tempCenterX;
                                centerY = tempCenterY;
                                minX = Math.min(...allDetectionKeypoints.map(kp => kp.x));
                                minY = Math.min(...allDetectionKeypoints.map(kp => kp.y));
                                maxX = Math.max(...allDetectionKeypoints.map(kp => kp.x));
                                maxY = Math.max(...allDetectionKeypoints.map(kp => kp.y));
                            } else {
                                centerX /= filteredDetectionCount;
                                centerY /= filteredDetectionCount;
                                console.log(`Filtered detection keypoints: ${filteredDetectionCount}/${matches.length} kept`);
                            }

                            const padding = 20;
                            const bboxX = Math.max(0, minX - padding);
                            const bboxY = Math.max(0, minY - padding);
                            const bboxWidth = (maxX - minX) + padding * 2;
                            const bboxHeight = (maxY - minY) + padding * 2;

                            // ISTERESI: Soglie diverse per mostrare/nascondere (evita flickering)
                            let showCharacter = false;
                            const currentState = this.characterStates.get(charId);

                            if (currentState && currentState.visible) {
                                // Gi√† visibile: nasconde solo se scende sotto soglia bassa
                                showCharacter = matches.length >= this.HYSTERESIS_HIDE;
                            } else {
                                // Non visibile: mostra solo se supera soglia alta
                                showCharacter = matches.length >= this.HYSTERESIS_SHOW;
                            }

                            // Aggiorna stato character
                            if (!this.characterStates.has(charId)) {
                                this.characterStates.set(charId, {
                                    visible: false,
                                    lastSeen: 0,
                                    positionHistory: []
                                });
                            }

                            const state = this.characterStates.get(charId);
                            state.lastSeen = Date.now();
                            state.visible = showCharacter;

                            // Aggiungi posizione alla history per smoothing
                            state.positionHistory.push({ x: centerX, y: centerY });
                            if (state.positionHistory.length > this.POSITION_HISTORY_SIZE) {
                                state.positionHistory.shift();
                            }

                            // Calcola posizione smoothed (media mobile)
                            const smoothX = state.positionHistory.reduce((sum, p) => sum + p.x, 0) / state.positionHistory.length;
                            const smoothY = state.positionHistory.reduce((sum, p) => sum + p.y, 0) / state.positionHistory.length;

                            this.detectedMarkers.set(charId, {
                                character: template.character,
                                screenX: smoothX,
                                screenY: smoothY,
                                matches: matches.length,
                                confidence: Math.min(1.0, matches.length / 50),
                                bbox: [bboxX, bboxY, bboxWidth, bboxHeight],
                                matchedKeypoints: matchedKeypoints,
                                showCharacter: showCharacter,
                                type: 'detection'
                            });

                            console.log(`Detection marker for ${template.character.name}: ${matches.length} matches, visible=${showCharacter}`);

                            // POSITIONING MARKER: Cerca solo se detection matches > soglia SHOW
                            if (matches.length >= this.HYSTERESIS_SHOW && this.positioningMarkerTemplates.has(charId)) {
                                console.log(`Detection passed threshold, checking positioning marker for ${template.character.name}`);
                                const posTemplate = this.positioningMarkerTemplates.get(charId);
                                const posMatches = this.matchFeatures(descriptors, posTemplate.descriptors);

                                if (posMatches.length > 0) {
                                    // PRIMA PASSATA: Calcola centro grezzo
                                    let tempCenterX = 0, tempCenterY = 0;
                                    const allKeypoints = [];

                                    posMatches.forEach(m => {
                                        const kp = keypoints.get(m.queryIdx);
                                        tempCenterX += kp.pt.x;
                                        tempCenterY += kp.pt.y;
                                        allKeypoints.push({ x: kp.pt.x, y: kp.pt.y });
                                    });

                                    tempCenterX /= posMatches.length;
                                    tempCenterY /= posMatches.length;

                                    // FILTRO OUTLIERS: Rimuovi keypoints troppo lontani dal centro
                                    // Calcola distanza media dal centro
                                    const distances = allKeypoints.map(kp => {
                                        const dx = kp.x - tempCenterX;
                                        const dy = kp.y - tempCenterY;
                                        return Math.sqrt(dx * dx + dy * dy);
                                    });

                                    const avgDistance = distances.reduce((sum, d) => sum + d, 0) / distances.length;
                                    const maxAllowedDistance = avgDistance * this.OUTLIER_THRESHOLD; // Soglia: 120% della distanza media

                                    // SECONDA PASSATA: Usa solo keypoints vicini al centro (rimuovi outliers)
                                    const posMatchedKeypoints = [];
                                    let posCenterX = 0, posCenterY = 0;
                                    let posMinX = Infinity, posMinY = Infinity, posMaxX = -Infinity, posMaxY = -Infinity;
                                    let filteredCount = 0;

                                    allKeypoints.forEach((kp, idx) => {
                                        if (distances[idx] <= maxAllowedDistance) {
                                            posCenterX += kp.x;
                                            posCenterY += kp.y;
                                            posMinX = Math.min(posMinX, kp.x);
                                            posMinY = Math.min(posMinY, kp.y);
                                            posMaxX = Math.max(posMaxX, kp.x);
                                            posMaxY = Math.max(posMaxY, kp.y);
                                            posMatchedKeypoints.push({ x: kp.x, y: kp.y, type: 'positioning' });
                                            filteredCount++;
                                        }
                                    });

                                    // Se troppi keypoints filtrati, usa comunque tutti (evita di perdere il marker)
                                    if (filteredCount < posMatches.length * 0.3) {
                                        console.log(`Too many outliers filtered (${filteredCount}/${posMatches.length}), using all keypoints`);
                                        posCenterX = tempCenterX;
                                        posCenterY = tempCenterY;
                                        // Ricalcola bbox con tutti i keypoints
                                        posMinX = Math.min(...allKeypoints.map(kp => kp.x));
                                        posMinY = Math.min(...allKeypoints.map(kp => kp.y));
                                        posMaxX = Math.max(...allKeypoints.map(kp => kp.x));
                                        posMaxY = Math.max(...allKeypoints.map(kp => kp.y));
                                    } else {
                                        posCenterX /= filteredCount;
                                        posCenterY /= filteredCount;
                                        console.log(`Filtered positioning keypoints: ${filteredCount}/${posMatches.length} kept (${posMatches.length - filteredCount} outliers removed)`);
                                        // Bbox gi√† calcolato solo sui keypoints filtrati (pi√π preciso)
                                    }

                                    // SMOOTHING per positioning marker (usa history separata)
                                    if (!state.positioningHistory) {
                                        state.positioningHistory = [];
                                    }
                                    state.positioningHistory.push({ x: posCenterX, y: posCenterY });
                                    if (state.positioningHistory.length > this.POSITION_HISTORY_SIZE) {
                                        state.positioningHistory.shift();
                                    }

                                    const smoothPosX = state.positioningHistory.reduce((sum, p) => sum + p.x, 0) / state.positioningHistory.length;
                                    const smoothPosY = state.positioningHistory.reduce((sum, p) => sum + p.y, 0) / state.positioningHistory.length;

                                    const posBboxX = Math.max(0, posMinX - padding);
                                    const posBboxY = Math.max(0, posMinY - padding);
                                    const posBboxWidth = (posMaxX - posMinX) + padding * 2;
                                    const posBboxHeight = (posMaxY - posMinY) + padding * 2;

                                    // Soglia positioning marker: richiede match di qualit√†
                                    const minPositioningMatches = 40;

                                    this.detectedPositioningMarkers.set(charId, {
                                        character: template.character,
                                        screenX: smoothPosX,
                                        screenY: smoothPosY,
                                        matches: posMatches.length,
                                        bbox: [posBboxX, posBboxY, posBboxWidth, posBboxHeight],
                                        matchedKeypoints: posMatchedKeypoints,
                                        useForPositioning: posMatches.length >= minPositioningMatches,
                                        type: 'positioning'
                                    });

                                    console.log(`Positioning marker for ${template.character.name}: ${posMatches.length} matches`);
                                }
                            }
                        }
                    }

                    // PERSISTENZA TEMPORALE: Mantieni visibili character recentemente visti
                    // MA SOLO se NON usano positioning marker (altrimenti devono seguire il marker in real-time)
                    const now = Date.now();
                    const PERSISTENCE_MS = this.PERSISTENCE_FRAMES * 500; // 500ms per frame

                    for (const [charId, state] of this.characterStates) {
                        const timeSinceLastSeen = now - state.lastSeen;
                        const character = this.characters.find(c => c.id === charId);

                        // Se il character era visibile e non √® passato troppo tempo, mantienilo visibile
                        if (state.visible && timeSinceLastSeen < PERSISTENCE_MS) {
                            if (!this.detectedMarkers.has(charId)) {
                                // Marker non rilevato questo frame

                                // SKIP persistenza se il character usa positioning marker
                                // (deve seguire il marker in tempo reale, non persistere)
                                if (character && character.positioning_marker_image) {
                                    console.log(`Skipping persistence for ${character.name}: uses positioning marker`);
                                    state.visible = false;
                                    continue;
                                }

                                // Applica persistenza solo per character senza positioning marker
                                if (character && state.positionHistory.length > 0) {
                                    const lastPos = state.positionHistory[state.positionHistory.length - 1];
                                    console.log(`Maintaining ${character.name} via persistence (${Math.round(timeSinceLastSeen)}ms ago)`);

                                    this.detectedMarkers.set(charId, {
                                        character: character,
                                        screenX: lastPos.x,
                                        screenY: lastPos.y,
                                        matches: 0,
                                        confidence: 0.5,
                                        bbox: [lastPos.x - 50, lastPos.y - 50, 100, 100],
                                        matchedKeypoints: [],
                                        showCharacter: true,
                                        type: 'persistence',
                                        isPersisted: true
                                    });
                                }
                            }
                        } else if (timeSinceLastSeen >= PERSISTENCE_MS) {
                            // Troppo tempo passato, marca come non visibile
                            state.visible = false;
                        }
                    }

                    // Aggiorna UI con status detection
                    const markerStatus = document.getElementById('marker-status');
                    if (this.detectedMarkers.size > 0) {
                        const detected = Array.from(this.detectedMarkers.values())[0];
                        const persistTag = detected.isPersisted ? ' (P)' : '';
                        markerStatus.textContent = `üü¢ ${detected.matches} matches${persistTag}`;
                        markerStatus.style.color = '#00ff00';
                    } else if (bestMatch && maxMatches > 0) {
                        markerStatus.textContent = `üü° ${maxMatches}/100 matches`;
                        markerStatus.style.color = '#ff9900';
                    } else {
                        markerStatus.textContent = `üî¥ No matches`;
                        markerStatus.style.color = '#ff0000';
                    }

                    // Cleanup
                    src.delete();
                    gray.delete();
                    keypoints.delete();
                    descriptors.delete();

                    // Disegna i rettangoli dei marker rilevati
                    this.drawMarkerHighlights();

                    // Aggiorna overlay se ci sono marker rilevati
                    if (this.detectedMarkers.size > 0) {
                        this.updateAROverlay();
                    }
                } catch (error) {
                    console.log('Detection error:', error);
                }
            }

            drawMarkerHighlights() {
                // Rimuovi i vecchi highlight
                const oldHighlights = document.querySelectorAll('.marker-highlight');
                oldHighlights.forEach(h => h.remove());

                // Rimuovi i vecchi keypoint markers
                const oldKeypoints = document.querySelectorAll('.keypoint-marker');
                oldKeypoints.forEach(k => k.remove());

                const scaleX = window.innerWidth / this.videoElement.videoWidth;
                const scaleY = window.innerHeight / this.videoElement.videoHeight;

                console.log(`Drawing highlights for ${this.detectedMarkers.size} detection markers`);

                // Disegna DETECTION MARKERS (verde)
                for (const [charId, marker] of this.detectedMarkers) {
                    const highlight = document.createElement('div');
                    highlight.className = 'marker-highlight';
                    highlight.style.left = (marker.bbox[0] * scaleX) + 'px';
                    highlight.style.top = (marker.bbox[1] * scaleY) + 'px';
                    highlight.style.width = (marker.bbox[2] * scaleX) + 'px';
                    highlight.style.height = (marker.bbox[3] * scaleY) + 'px';

                    // Label verde per detection
                    const label = document.createElement('div');
                    label.style.cssText = 'position: absolute; top: -20px; left: 0; background: rgba(0,255,0,0.8); color: black; padding: 2px 8px; font-size: 10px; border-radius: 3px; font-weight: bold;';
                    label.textContent = `D:${marker.matches}`;
                    highlight.appendChild(label);

                    document.getElementById('ar-overlay').appendChild(highlight);

                    // Keypoints VERDI per detection marker
                    if (marker.matchedKeypoints && marker.matchedKeypoints.length > 0) {
                        console.log(`Drawing ${marker.matchedKeypoints.length} GREEN detection keypoints`);
                        marker.matchedKeypoints.forEach(kp => {
                            const dot = document.createElement('div');
                            dot.className = 'keypoint-marker';
                            dot.style.cssText = `
                                position: fixed;
                                left: ${(kp.x * scaleX) - 3}px;
                                top: ${(kp.y * scaleY) - 3}px;
                                width: 6px;
                                height: 6px;
                                background: #00ff00;
                                border-radius: 50%;
                                box-shadow: 0 0 5px rgba(0,255,0,1);
                                pointer-events: none;
                                z-index: 9999;
                            `;
                            document.body.appendChild(dot);
                        });
                    }
                }

                // Disegna POSITIONING MARKERS (blu)
                if (this.detectedPositioningMarkers && this.detectedPositioningMarkers.size > 0) {
                    console.log(`Drawing highlights for ${this.detectedPositioningMarkers.size} positioning markers`);

                    for (const [charId, marker] of this.detectedPositioningMarkers) {
                        const highlight = document.createElement('div');
                        highlight.className = 'marker-highlight';
                        highlight.style.cssText = `
                            position: absolute;
                            left: ${marker.bbox[0] * scaleX}px;
                            top: ${marker.bbox[1] * scaleY}px;
                            width: ${marker.bbox[2] * scaleX}px;
                            height: ${marker.bbox[3] * scaleY}px;
                            border: 2px solid #00aaff;
                            box-shadow: 0 0 10px rgba(0,170,255,0.5);
                            pointer-events: none;
                        `;

                        // Label blu per positioning
                        const label = document.createElement('div');
                        label.style.cssText = 'position: absolute; top: -20px; right: 0; background: rgba(0,170,255,0.8); color: black; padding: 2px 8px; font-size: 10px; border-radius: 3px; font-weight: bold;';
                        label.textContent = `P:${marker.matches}`;
                        highlight.appendChild(label);

                        document.getElementById('ar-overlay').appendChild(highlight);

                        // Keypoints BLU per positioning marker
                        if (marker.matchedKeypoints && marker.matchedKeypoints.length > 0) {
                            console.log(`Drawing ${marker.matchedKeypoints.length} BLUE positioning keypoints`);
                            marker.matchedKeypoints.forEach(kp => {
                                const dot = document.createElement('div');
                                dot.className = 'keypoint-marker';
                                dot.style.cssText = `
                                    position: fixed;
                                    left: ${(kp.x * scaleX) - 3}px;
                                    top: ${(kp.y * scaleY) - 3}px;
                                    width: 6px;
                                    height: 6px;
                                    background: #00aaff;
                                    border-radius: 50%;
                                    box-shadow: 0 0 5px rgba(0,170,255,1);
                                    pointer-events: none;
                                    z-index: 9999;
                                `;
                                document.body.appendChild(dot);
                            });
                        }
                    }
                }
            }

            matchFeatures(desc1, desc2) {
                if (!desc1 || !desc2 || desc1.rows === 0 || desc2.rows === 0) {
                    return [];
                }

                const bf = new cv.BFMatcher(cv.NORM_HAMMING, true);
                const matches = new cv.DMatchVector();
                bf.match(desc1, desc2, matches);

                // Filtra i match migliori (soglia pi√π permissiva per scene ampie)
                const goodMatches = [];
                for (let i = 0; i < matches.size(); i++) {
                    const match = matches.get(i);
                    if (match.distance < 70) { // Threshold pi√π permissivo per variazioni di luce/angolazione
                        goodMatches.push(match);
                    }
                }

                matches.delete();
                return goodMatches;
            }

            initGPS() {
                if (!navigator.geolocation) {
                    this.showError('GPS non supportato su questo dispositivo');
                    return;
                }

                const options = {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 60000
                };

                navigator.geolocation.watchPosition(
                    (position) => {
                        this.currentPosition = position;
                        this.updateGPSDisplay();
                        this.updateAROverlay();
                        this.updateCharacterPointer();
                    },
                    (error) => {
                        this.showError('Errore GPS: ' + error.message);
                    },
                    options
                );
            }

            setupCompassButton() {
                const button = document.getElementById('compass-button');
                button.addEventListener('click', async () => {
                    button.textContent = 'Activating...';
                    await this.initOrientation();
                });
            }

            async initOrientation() {
                try {
                    const status = document.getElementById('compass-status');

                    // Richiedi permessi per orientamento dispositivo (iOS 13+)
                    if (typeof DeviceOrientationEvent !== 'undefined' &&
                        typeof DeviceOrientationEvent.requestPermission === 'function') {

                        const permission = await DeviceOrientationEvent.requestPermission();

                        if (permission === 'granted') {
                            this.startOrientationListening();
                            status.textContent = 'ON';
                            document.getElementById('compass-button').style.display = 'none';
                        } else {
                            status.textContent = 'DENIED';
                        }
                    } else {
                        // Per Android e browser pi√π vecchi
                        this.startOrientationListening();
                        status.textContent = 'ON';
                        document.getElementById('compass-button').style.display = 'none';
                    }
                } catch (error) {
                    console.log('Errore richiesta permessi orientamento:', error);
                    document.getElementById('compass-status').textContent = 'ERROR';
                }
            }

            startOrientationListening() {
                if (window.DeviceOrientationEvent) {
                    // Usa deviceorientationabsolute per il nord magnetico assoluto (iOS/Android moderni)
                    window.addEventListener('deviceorientationabsolute', (event) => {
                        if (event.alpha !== null) {
                            // Per iOS, event.alpha √® relativo al nord magnetico
                            // Per Android con supporto assoluto, √® gi√† corretto
                            this.currentHeading = event.alpha;
                            document.getElementById('compass-status').textContent = `${Math.round(event.alpha)}¬∞`;
                            this.throttledUpdatePointer();
                        }
                    });

                    // Fallback per dispositivi senza supporto assoluto
                    window.addEventListener('deviceorientation', (event) => {
                        if (event.alpha !== null) {
                            // Su alcuni dispositivi potrebbe essere necessario correggere l'orientamento
                            let heading = event.alpha;

                            // Correzione per iOS dove l'orientamento potrebbe essere diverso
                            if (event.webkitCompassHeading) {
                                heading = event.webkitCompassHeading;
                            }

                            this.currentHeading = heading;
                            document.getElementById('compass-status').textContent = `${Math.round(heading)}¬∞`;
                            this.throttledUpdatePointer();
                        }
                    });
                } else {
                    document.getElementById('compass-status').textContent = 'NOT_SUPPORTED';
                }
            }

            throttledUpdatePointer() {
                const now = Date.now();
                if (now - this.lastUpdate > 50) { // Aggiorna max ogni 50ms
                    this.lastUpdate = now;
                    this.updateCharacterPointer();
                }
            }

            findNearestCharacter() {
                if (!this.currentPosition || this.characters.length === 0) return null;

                let nearest = null;
                let minDistance = Infinity;

                this.characters.forEach(character => {
                    const distance = this.calculateDistance(
                        this.currentPosition.coords.latitude,
                        this.currentPosition.coords.longitude,
                        character.target_latitude,
                        character.target_longitude
                    );

                    if (distance < minDistance) {
                        minDistance = distance;
                        nearest = { ...character, distance: distance };
                    }
                });

                return nearest;
            }

            async loadCharacterData() {
                try {
                    // OTTIMIZZAZIONE: Usa dati embedded (zero latency)
                    if (window.EMBEDDED_CHARACTERS && window.EMBEDDED_CHARACTERS.length > 0) {
                        this.characters = window.EMBEDDED_CHARACTERS;
                        this.charactersLastUpdate = Date.now();
                        console.log('‚úÖ Characters loaded from embedded data (0ms latency):', this.characters.length, 'characters');
                        return;
                    }

                    // Fallback: carica da API se embedding non disponibile
                    console.log('‚ö†Ô∏è Embedded data not found, falling back to API...');
                    const response = await fetch('/api/characters/');
                    const data = await response.json();
                    this.characters = data.characters;
                    this.charactersLastUpdate = Date.now();
                    console.log('Characters loaded from API:', this.characters.length, 'characters');
                } catch (error) {
                    this.showError('Errore caricamento personaggi: ' + error.message);
                }
            }

            async refreshCharacterData() {
                // Refresh manuale dei dati (chiamato quando necessario)
                try {
                    console.log('üîÑ Refreshing character data from server...');
                    const response = await fetch('/api/characters/');
                    const data = await response.json();
                    this.characters = data.characters;
                    this.charactersLastUpdate = Date.now();

                    // Ricarica anche i marker images se cambiate
                    if (openCvReady) {
                        await this.loadMarkerImages();
                    }

                    console.log('‚úÖ Character data refreshed:', this.characters.length, 'characters');
                } catch (error) {
                    console.error('Error refreshing character data:', error);
                }
            }

            updateGPSDisplay() {
                if (this.currentPosition) {
                    const lat = this.currentPosition.coords.latitude.toFixed(6);
                    const lng = this.currentPosition.coords.longitude.toFixed(6);
                    const accuracy = Math.round(this.currentPosition.coords.accuracy);
                    const altitude = this.currentPosition.coords.altitude;

                    document.getElementById('gps-coords').textContent = `${lat}, ${lng}`;
                    document.getElementById('gps-accuracy').textContent = `¬±${accuracy}m`;

                    if (altitude !== null) {
                        document.getElementById('gps-altitude').textContent = `${Math.round(altitude)}m`;
                    } else {
                        document.getElementById('gps-altitude').textContent = 'N/A';
                    }
                }
            }

            updateCharacterPointer() {
                const nearest = this.findNearestCharacter();
                const pointer = document.getElementById('character-pointer');
                const arrow = document.getElementById('pointer-arrow');
                const nameEl = document.getElementById('pointer-name');
                const distanceEl = document.getElementById('pointer-distance');
                const nearestDistanceEl = document.getElementById('nearest-distance');

                if (nearest && this.currentPosition) {
                    // Aggiorna info nel pannello superiore
                    nearestDistanceEl.textContent = `${Math.round(nearest.distance)}m`;

                    // Calcola la direzione verso il character pi√π vicino
                    const bearing = this.calculateBearing(
                        this.currentPosition.coords.latitude,
                        this.currentPosition.coords.longitude,
                        nearest.target_latitude,
                        nearest.target_longitude
                    );

                    // Calcola la direzione relativa considerando l'orientamento del dispositivo
                    // La freccia punta nella direzione corretta relativa all'orientamento
                    const relativeBearing = (bearing - this.currentHeading + 360) % 360;

                    // Mostra il puntatore e aggiorna la direzione della freccia
                    pointer.style.display = 'block';
                    arrow.style.transform = `rotate(${relativeBearing}deg)`;
                    nameEl.textContent = nearest.name;
                    distanceEl.textContent = `${Math.round(nearest.distance)}m`;

                    // Aggiorna il character pi√π vicino
                    this.nearestCharacter = nearest;
                } else {
                    pointer.style.display = 'none';
                    nearestDistanceEl.textContent = '-';
                    this.nearestCharacter = null;
                }
            }

            updateAROverlay() {
                if (!this.currentPosition || this.characters.length === 0) return;

                const overlay = document.getElementById('ar-overlay');

                // NON cancellare tutto ogni frame - aggiorna solo le posizioni esistenti
                // Questo permette alle transizioni CSS di funzionare
                const existingCharacters = new Set();

                this.characters.forEach(character => {
                    const distance = this.calculateDistance(
                        this.currentPosition.coords.latitude,
                        this.currentPosition.coords.longitude,
                        character.target_latitude,
                        character.target_longitude
                    );

                    if (distance <= character.activation_distance) {
                        this.createOrUpdateARCharacter(character, distance);
                        existingCharacters.add(character.id);
                    }
                });

                // Rimuovi character che non sono pi√π nell'area con fade out
                const allCharDivs = overlay.querySelectorAll('.ar-character');
                allCharDivs.forEach(div => {
                    const charId = parseInt(div.dataset.characterId);
                    if (!existingCharacters.has(charId)) {
                        // Fade out prima di rimuovere
                        div.style.opacity = '0';
                        setTimeout(() => div.remove(), 300);
                    }
                });
            }

            createOrUpdateARCharacter(character, distance) {
                const overlay = document.getElementById('ar-overlay');

                // Cerca se il character esiste gi√†
                let characterDiv = overlay.querySelector(`[data-character-id="${character.id}"]`);
                const isNew = !characterDiv;

                if (isNew) {
                    characterDiv = document.createElement('div');
                    characterDiv.className = 'ar-character';
                    characterDiv.dataset.characterId = character.id;
                    characterDiv.style.opacity = '0'; // Inizia invisibile per fade in
                }

                let screenPosition;
                let scale;

                // MODALIT√Ä MARKER: Sistema a doppio check
                if (character.use_marker && this.detectedMarkers.has(character.id)) {
                    const detectionMarker = this.detectedMarkers.get(character.id);

                    // CHECK 1: Detection marker decide SE mostrare (soglia 100)
                    if (!detectionMarker.showCharacter) {
                        return;
                    }

                    // CHECK 2: Positioning marker decide DOVE mostrare (se disponibile, altrimenti fallback)
                    let positioningMarker = null;
                    if (this.detectedPositioningMarkers && this.detectedPositioningMarkers.has(character.id)) {
                        const posMarker = this.detectedPositioningMarkers.get(character.id);
                        if (posMarker.useForPositioning) {
                            positioningMarker = posMarker;
                        }
                    }

                    // Usa positioning marker se disponibile, altrimenti detection marker
                    const markerForPosition = positioningMarker || detectionMarker;
                    const markerX = markerForPosition.screenX;
                    const markerY = markerForPosition.screenY;
                    const markerWidth = markerForPosition.bbox[2];

                    // Converti coordinate video in coordinate schermo
                    const scaleX = window.innerWidth / this.videoElement.videoWidth;
                    const scaleY = window.innerHeight / this.videoElement.videoHeight;

                    // Applica offset dal marker
                    const pixelsPerMeter = markerWidth * scaleX / 0.3; // Assumo oggetto di ~30cm
                    screenPosition = {
                        x: (markerX * scaleX) + (character.marker_offset_x * pixelsPerMeter),
                        y: (markerY * scaleY) + (character.marker_offset_y * pixelsPerMeter),
                        visible: true
                    };

                    // Scala basata sulla dimensione del marker e distanza stimata
                    const estimatedDistance = 1.0 / (markerWidth / this.videoElement.videoWidth);
                    scale = (character.base_size || 1.0) * Math.max(0.5, Math.min(2, 1 / estimatedDistance));

                    console.log(`Character ${character.name}: Detection=${detectionMarker.matches}, Positioning=${positioningMarker ? positioningMarker.matches : 'N/A'}, Using ${positioningMarker ? 'POSITIONING' : 'DETECTION'} for position`);
                } else if (character.use_marker) {
                    // Marker abilitato ma non rilevato - non mostrare
                    return;
                } else {
                    // MODALIT√Ä GPS: Usa bearing e distanza normale
                    const bearing = this.calculateBearing(
                        this.currentPosition.coords.latitude,
                        this.currentPosition.coords.longitude,
                        character.target_latitude,
                        character.target_longitude
                    );

                    screenPosition = this.worldToScreen(bearing, distance, character);

                    // Se il personaggio √® fuori dal campo visivo, non mostrarlo
                    if (!screenPosition || !screenPosition.visible) {
                        return;
                    }

                    scale = screenPosition.scale;
                }

                // Applica la scala
                const baseSize = 80;
                const imgSize = baseSize * scale;

                // AGGIORNA posizione (le transizioni CSS renderanno il movimento smooth)
                characterDiv.style.left = screenPosition.x + 'px';
                characterDiv.style.top = screenPosition.y + 'px';
                characterDiv.style.transform = 'translate(-50%, -50%)';

                // Aggiorna contenuto solo se necessario (per evitare flickering)
                if (isNew || !characterDiv.querySelector('img')) {
                    console.log(`Character ${character.name}: distance=${Math.round(distance)}m, scale=${scale.toFixed(2)}, mode=${character.display_mode}`);
                    if (character.character_image) {
                        characterDiv.innerHTML = `
                            <img src="${character.character_image}"
                                 alt="${character.name}"
                                 style="width: ${imgSize}px; height: ${imgSize}px;">
                            <div class="ar-character-info">
                                <div><strong>${character.name}</strong></div>
                                <div>${Math.round(distance)}m</div>
                            </div>
                        `;
                    } else {
                        console.log(`Character ${character.name} has no image!`);
                        return;
                    }
                } else {
                    // Aggiorna solo dimensioni immagine e distanza
                    const img = characterDiv.querySelector('img');
                    const distanceDiv = characterDiv.querySelector('.ar-character-info div:last-child');
                    if (img) {
                        img.style.width = imgSize + 'px';
                        img.style.height = imgSize + 'px';
                    }
                    if (distanceDiv) {
                        distanceDiv.textContent = Math.round(distance) + 'm';
                    }
                }

                // Aggiungi all'overlay se nuovo
                if (isNew) {
                    overlay.appendChild(characterDiv);
                    // Fade in dopo un frame
                    setTimeout(() => {
                        characterDiv.style.opacity = '1';
                    }, 10);
                }
            }

            calculateDistance(lat1, lon1, lat2, lon2) {
                const R = 6371e3; // Raggio Terra in metri
                const œÜ1 = lat1 * Math.PI/180;
                const œÜ2 = lat2 * Math.PI/180;
                const ŒîœÜ = (lat2-lat1) * Math.PI/180;
                const ŒîŒª = (lon2-lon1) * Math.PI/180;

                const a = Math.sin(ŒîœÜ/2) * Math.sin(ŒîœÜ/2) +
                        Math.cos(œÜ1) * Math.cos(œÜ2) *
                        Math.sin(ŒîŒª/2) * Math.sin(ŒîŒª/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

                return R * c;
            }

            calculateBearing(lat1, lon1, lat2, lon2) {
                const œÜ1 = lat1 * Math.PI/180;
                const œÜ2 = lat2 * Math.PI/180;
                const ŒîŒª = (lon2-lon1) * Math.PI/180;

                const y = Math.sin(ŒîŒª) * Math.cos(œÜ2);
                const x = Math.cos(œÜ1) * Math.sin(œÜ2) -
                        Math.sin(œÜ1) * Math.cos(œÜ2) * Math.cos(ŒîŒª);

                const Œ∏ = Math.atan2(y, x);

                return (Œ∏*180/Math.PI + 360) % 360;
            }

            worldToScreen(bearing, distance, character) {
                const screenWidth = window.innerWidth;
                const screenHeight = window.innerHeight;

                // Campo visivo della fotocamera (tipicamente 60-80 gradi per smartphone)
                const FOV = 70;

                // Calcola il bearing relativo alla direzione della fotocamera
                let relativeBearing = (bearing - this.currentHeading + 360) % 360;

                // Normalizza il bearing tra -180 e 180 gradi
                if (relativeBearing > 180) {
                    relativeBearing -= 360;
                }

                // Controlla se il personaggio √® nel campo visivo
                if (Math.abs(relativeBearing) > FOV / 2) {
                    // Fuori dal campo visivo - non mostrare
                    return null;
                }

                // Mappa il bearing su coordinate schermo
                // 0 gradi (davanti) = centro schermo
                // -FOV/2 = sinistra, +FOV/2 = destra
                const x = screenWidth / 2 + (relativeBearing / FOV) * screenWidth;

                // Calcola posizione verticale considerando altitudine e height_offset
                let y = screenHeight * 0.5; // Centro verticale di default

                // Se abbiamo dati di altitudine GPS
                if (this.currentPosition.coords.altitude !== null && character.altitude !== 0) {
                    const altitudeDiff = character.altitude - this.currentPosition.coords.altitude + character.height_offset;
                    // Converti differenza altitudine in offset verticale (negativo = pi√π in alto)
                    const altitudeOffset = -altitudeDiff * 2; // Pixel per metro
                    y = screenHeight * 0.5 + altitudeOffset;
                } else {
                    // Fallback: usa distanza per calcolare posizione verticale
                    // Pi√π vicino = pi√π in basso (effetto prospettico)
                    const verticalOffset = Math.max(0, Math.min(1, distance / 100));

                    // Applica height_offset
                    const heightAdjustment = character.height_offset * -3; // Pixel per metro

                    if (character.display_mode === 'floating') {
                        y = screenHeight * (0.3 + verticalOffset * 0.1) + heightAdjustment;
                    } else if (character.display_mode === 'wall') {
                        y = screenHeight * 0.4 + heightAdjustment;
                    } else { // standing
                        y = screenHeight * (0.5 + verticalOffset * 0.15) + heightAdjustment;
                    }
                }

                // Calcola la scala in base alla distanza e base_size
                const baseScale = Math.max(0.3, Math.min(2, 50 / distance));
                const scale = baseScale * (character.base_size || 1.0);

                return {
                    x: x,
                    y: y,
                    scale: scale,
                    visible: true
                };
            }

            showError(message) {
                const errorDiv = document.getElementById('error-message');
                errorDiv.textContent = message;
                errorDiv.style.display = 'block';
                setTimeout(() => {
                    errorDiv.style.display = 'none';
                }, 5000);
            }
        }

        // Avvia l'applicazione AR quando la pagina √® caricata
        document.addEventListener('DOMContentLoaded', () => {
            new ARCamera();
        });

        // Gestisci il cambio di orientamento
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                location.reload();
            }, 500);
        });
    </script>
</body>
</html>